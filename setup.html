<!doctype html>
<html lang="de">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Poker – Turnier Setup</title>

    <link rel="manifest" href="./manifest.webmanifest">
    <meta name="theme-color" content="#0b0f14">

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

    <style>
        :root{ --card-radius: 18px; }
        body{
            background:
                    radial-gradient(1200px 600px at 20% 0%, #1b3a2a 0%, rgba(27,58,42,0) 55%),
                    radial-gradient(1000px 500px at 80% 10%, #2a1b3a 0%, rgba(42,27,58,0) 55%),
                    #0b0f14;
            color:#e9eef5;
        }
        .navbar{
            backdrop-filter: blur(10px);
            background: rgba(10, 14, 20, 0.65) !important;
            border-bottom: 1px solid rgba(255,255,255,0.08);
        }
        .card{
            border: 1px solid rgba(255,255,255,0.10);
            background: rgba(255,255,255,0.06);
            border-radius: var(--card-radius);
            box-shadow: 0 10px 30px rgba(0,0,0,0.35);
        }
        .form-control, .form-select{
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.12);
            color: #e9eef5;
        }
        .form-control::placeholder{ color: rgba(233,238,245,0.75); }
        .form-control:focus, .form-select:focus{
            box-shadow: 0 0 0 .25rem rgba(13,110,253,0.18);
            border-color: rgba(13,110,253,0.55);
        }
        .badge-soft{
            background: rgba(255,255,255,0.12);
            border: 1px solid rgba(255,255,255,0.12);
            color: #e9eef5;
        }
        .small-muted{ color: rgba(233,238,245,0.92) !important; }
        label.form-label{ color: rgba(233,238,245,0.95) !important; }
        .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

        .btn-outline-light{
            color: rgba(233,238,245,0.95);
            border-color: rgba(233,238,245,0.35);
        }
        .btn-outline-light:hover{
            color:#0b0f14;
            background: rgba(233,238,245,0.92);
            border-color: rgba(233,238,245,0.92);
        }

        .table-wrap{
            background: rgba(255,255,255,0.96);
            border-radius: 14px;
            overflow: auto;
            border: 1px solid rgba(0,0,0,0.10);
            max-width: 100%;
        }
        .table{ color:#111 !important; margin:0; }
        .table thead th{
            color:#111 !important;
            background: rgba(0,0,0,0.04) !important;
            border-bottom: 1px solid rgba(0,0,0,0.12) !important;
            white-space: nowrap;
            font-size: 13px;
        }
        .table tbody td, .table tbody th{
            color:#111 !important;
            border-color: rgba(0,0,0,0.08) !important;
            vertical-align: middle;
            font-size: 13px;
            white-space: nowrap;
        }
        .table-hover tbody tr:hover{ background: rgba(0,0,0,0.03) !important; }
        .table .badge-soft{
            background: rgba(0,0,0,0.06) !important;
            border: 1px solid rgba(0,0,0,0.12) !important;
            color:#111 !important;
        }
        .table-wrap input.form-control,
        .table-wrap select.form-select{
            background: rgba(0,0,0,0.06) !important;
            border: 1px solid rgba(0,0,0,0.18) !important;
            color:#111 !important;
        }

        .avatar{
            width: 34px; height: 34px;
            border-radius: 999px;
            object-fit: cover;
            border: 1px solid rgba(255,255,255,0.20);
            background: rgba(255,255,255,0.10);
        }
        .dropdown-menu{
            background: rgba(12, 16, 22, 0.98);
            border: 1px solid rgba(255,255,255,0.10);
            border-radius: 14px;
            box-shadow: 0 18px 60px rgba(0,0,0,0.55);
            padding: 8px;
        }
        .dropdown-item{
            border-radius: 12px;
            color: rgba(233,238,245,0.95);
        }
        .dropdown-item:hover{
            background: rgba(13,110,253,0.14);
            color:#fff;
        }
        .player-item{
            display:flex;
            align-items:center;
            gap:10px;
            padding:10px 10px;
        }
        .player-item .pname{ font-weight: 700; color:#fff; }
        .player-item .puid{ font-size: 12px; color: rgba(233,238,245,0.92); }

        .pill{
            border-radius: 999px;
            border: 1px solid rgba(255,255,255,0.14);
            background: rgba(255,255,255,0.06);
            padding: 6px 10px;
            display:inline-flex;
            align-items:center;
            gap:8px;
            color:#fff;
        }

        .danger-zone{
            border: 1px solid rgba(220,53,69,0.35);
            background: rgba(220,53,69,0.08);
        }

        .state-dot{ width:10px; height:10px; border-radius:999px; display:inline-block; margin-right:8px; }
        .s-setup{ background:#cbd5e1; }
        .s-running{ background:#57e389; }
        .s-paused{ background:#fbbf24; }
        .s-break{ background:#60a5fa; }
        .s-finished{ background:#ff6b6b; }

        .table-seat{
            width: 34px;
            height: 34px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.12);
            background: rgba(255,255,255,0.06);
            display:flex;
            align-items:center;
            justify-content:center;
            font-size: 12px;
            color:#fff;
            position: relative;
            overflow: hidden;
        }
        .table-seat.filled{
            background: rgba(13,110,253,0.20);
            border-color: rgba(13,110,253,0.40);
        }
        .table-seat.admin{
            background: rgba(255,193,7,0.20);
            border-color: rgba(255,193,7,0.40);
        }
        .table-seat.empty{ opacity: .75; }
        .table-seat.disabled{
            opacity:.45;
            filter: grayscale(1);
            pointer-events: none;
        }
        .table-card{
            border: 1px solid rgba(255,255,255,0.10);
            background: rgba(255,255,255,0.06);
            border-radius: 18px;
            padding: 12px;
        }
        .seats-grid{
            display:grid;
            grid-template-columns: repeat(9, 34px);
            gap: 8px;
            justify-content: start;
            align-items: start;
        }
        @media (max-width: 992px){ .seats-grid{ grid-template-columns: repeat(6, 34px); } }
        @media (max-width: 576px){ .seats-grid{ grid-template-columns: repeat(5, 34px); } }

        .readonly-gray{
            opacity: .55;
            filter: grayscale(1);
            pointer-events: none;
        }

        .win-inline{
            display:flex;
            gap:6px;
            align-items:center;
            justify-content:flex-end;
            min-width: 520px;
        }
        .win-inline .form-control{ height: 30px; }
        .win-inline .btn{ height: 30px; padding-top: 3px; padding-bottom: 3px; }
        @media (max-width: 992px){
            .win-inline{ min-width: 420px; }
        }
    </style>
</head>

<body>
<nav class="navbar navbar-expand-lg navbar-dark sticky-top">
    <div class="container py-2">
        <a class="navbar-brand fw-semibold" href="#">Poker – Turnier Setup</a>
        <div class="ms-auto d-flex gap-2 align-items-center">
            <span class="badge badge-soft" id="authStatus">Nicht eingeloggt</span>
            <a href="./index.html" class="btn btn-sm btn-outline-light d-none" id="btnBackToApp">
                Zur App
            </a>
            <a class="btn btn-sm btn-outline-light d-none" id="btnOpenDisplay" href="#" target="_blank" rel="noopener">Display öffnen</a>
            <button class="btn btn-sm btn-outline-light d-none" id="btnLogout" type="button">Logout</button>
        </div>
    </div>
</nav>

<main class="container my-4">

    <!-- LOGIN -->
    <div id="loginArea" class="row g-3">
        <div class="col-12 col-lg-6">
            <div class="card p-3 p-md-4 h-100">
                <h1 class="h4 mb-1 text-white">Setup Login</h1>
                <div class="small-muted mb-3">E-Mail/Passwort oder Google via Firebase Auth.</div>

                <form id="loginForm" class="row g-2">
                    <div class="col-12">
                        <label class="form-label mb-1">E-Mail</label>
                        <input class="form-control" type="email" id="loginEmail" required>
                    </div>
                    <div class="col-12">
                        <label class="form-label mb-1">Passwort</label>
                        <input class="form-control" type="password" id="loginPassword" required>
                    </div>
                    <div class="col-12 d-grid mt-2">
                        <button class="btn btn-primary btn-lg" type="submit">Einloggen</button>
                    </div>
                </form>

                <div class="d-grid mt-3">
                    <button class="btn btn-outline-light btn-lg" id="btnGoogle" type="button">Mit Google einloggen</button>
                </div>

                <div class="small text-danger mt-3" id="loginMsg"></div>
            </div>
        </div>
    </div>

    <!-- APP -->
    <div id="appArea" class="d-none">

        <div class="row g-3 mb-3">
            <div class="col-12">
                <div class="card p-3 p-md-4">
                    <div class="d-flex justify-content-between align-items-start gap-3 flex-wrap">
                        <div>
                            <h1 class="h3 mb-1 text-white">Turniere</h1>
                            <div class="small-muted" id="whoAmI"></div>
                        </div>

                        <div class="text-end">
                            <div class="pill">
                                <span class="mono">TID:</span>
                                <span class="fw-semibold mono" id="tidBadge">—</span>
                            </div>
                            <div class="mt-2">
                                <span class="badge badge-soft" id="statusBadge">Status: —</span>
                            </div>
                        </div>
                    </div>

                    <hr class="border border-light border-opacity-10 my-3">

                    <div class="row g-2">
                        <div class="col-12">
                            <div class="small-muted mb-2">Alle Turniere (live) – öffnen per Button</div>
                            <div class="table-wrap table-responsive">
                                <table class="table table-hover align-middle">
                                    <thead>
                                    <tr>
                                        <th>Status</th>
                                        <th>Name</th>
                                        <th class="text-end">Players</th>
                                        <th class="text-end">Aktion</th>
                                    </tr>
                                    </thead>
                                    <tbody id="tbodyTournaments"></tbody>
                                </table>
                            </div>
                            <div class="small text-danger mt-2" id="tournamentsMsg"></div>
                        </div>
                    </div>

                    <hr class="border border-light border-opacity-10 my-3">

                    <div class="small-muted mb-2">Neues Turnier erstellen</div>
                    <div class="row g-2">
                        <div class="col-12 col-md-6">
                            <label class="form-label mb-1">Name</label>
                            <input class="form-control" id="newName" placeholder="z.B. Homegame Winter Cup">
                        </div>
                        <div class="col-12 col-md-6">
                            <label class="form-label mb-1">Turnierart</label>
                            <select class="form-select" id="newType">
                                <option value="rebuy_addon">Rebuy (+ optional Addon)</option>
                                <option value="freezeout">Freezeout</option>
                            </select>
                        </div>

                        <div class="col-12 col-md-4">
                            <label class="form-label mb-1">Buy-in (€)</label>
                            <input class="form-control" type="number" step="0.01" id="newBuyIn" value="20">
                        </div>
                        <div class="col-12 col-md-4">
                            <label class="form-label mb-1">Startstack</label>
                            <input class="form-control" type="number" step="1" id="newStack" value="20000">
                        </div>
                        <div class="col-12 col-md-4">
                            <label class="form-label mb-1">Max Spieler</label>
                            <input class="form-control" type="number" step="1" id="newMaxPlayers" value="50">
                        </div>

                        <div class="col-12 d-grid mt-2">
                            <button class="btn btn-primary btn-lg" id="btnCreateTournament" type="button">Turnier erstellen</button>
                        </div>

                        <div class="small text-danger mt-2" id="createMsg"></div>
                    </div>

                </div>
            </div>
        </div>

        <!-- Tabs -->
        <div class="row g-3">
            <div class="col-12">
                <div class="card p-3 p-md-4">
                    <ul class="nav nav-pills gap-2" role="tablist">
                        <li class="nav-item" role="presentation">
                            <button class="nav-link active" data-bs-toggle="pill" data-bs-target="#tabControls" type="button" role="tab">Controls</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" data-bs-toggle="pill" data-bs-target="#tabPlayers" type="button" role="tab">Spieler</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" data-bs-toggle="pill" data-bs-target="#tabTables" type="button" role="tab">Tische</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" data-bs-toggle="pill" data-bs-target="#tabStructure" type="button" role="tab">Struktur</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" data-bs-toggle="pill" data-bs-target="#tabPayouts" type="button" role="tab">Gewinne</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" data-bs-toggle="pill" data-bs-target="#tabDanger" type="button" role="tab">Danger</button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link d-none" id="tabPayoutBtn"
                                    data-bs-toggle="pill" data-bs-target="#tabPayout"
                                    type="button" role="tab" aria-controls="tabPayout" aria-selected="false">
                                Auszahlung
                            </button>
                        </li>

                    </ul>

                    <hr class="border border-light border-opacity-10 my-3">

                    <div class="tab-content">

                        <div class="tab-pane fade" id="tabPayout" role="tabpanel" aria-labelledby="tabPayoutBtn">
                            <div class="card p-3 p-md-4">
                                <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
                                    <div>
                                        <h2 class="h5 mb-0" style="color:#fff;">Auszahlung</h2>
                                        <div class="small-muted">
                                            Netto-Beträge (Buy-in/Rebuys/Addons bereits eingerechnet). Mit „Auf Spieler buchen“ werden Einträge pro Spieler erzeugt.
                                        </div>
                                    </div>
                                    <button id="btnAutoPlaces" class="btn btn-warning" type="button">
                                        Plätze automatisch setzen
                                    </button>
                                    <button class="btn btn-primary" id="btnBookPayouts" type="button" disabled>
                                        Auf Spieler buchen
                                    </button>
                                </div>

                                <div class="small text-danger mt-2" id="payoutMsg"></div>

                                <hr class="border border-light border-opacity-10 my-3">

                                <div class="table-responsive">
                                    <table class="table table-hover align-middle mb-0">
                                        <thead>
                                        <tr>
                                            <th>Spieler</th>
                                            <th class="text-end">Netto</th>
                                            <th>Status</th>
                                        </tr>
                                        </thead>
                                        <tbody id="tbodyPayout"></tbody>
                                    </table>
                                </div>
                            </div>
                        </div>


                        <!-- CONTROLS -->
                        <div class="tab-pane fade show active" id="tabControls" role="tabpanel">
                            <div class="row g-3">
                                <div class="col-12 col-lg-7">
                                    <div class="card p-3 p-md-4 h-100">
                                        <h2 class="h5 text-white mb-1">Start / Pause / Break</h2>


                                        <div class="d-flex gap-2 flex-wrap">
                                            <button class="btn btn-primary" id="btnStart" type="button" disabled>Start</button>
                                            <button class="btn btn-outline-light" id="btnPause" type="button" disabled>Pause</button>
                                            <button class="btn btn-outline-light" id="btnBreak" type="button" disabled>Break</button>
                                            <button class="btn btn-outline-light" id="btnNext" type="button" disabled>Nächstes Level</button>
                                            <button class="btn btn-outline-danger" id="btnFinish" type="button" disabled>Finish</button>
                                        </div>

                                        <div class="small text-danger mt-2" id="controlsMsg"></div>

                                        <hr class="border border-light border-opacity-10 my-3">

                                        <div class="row g-2">
                                            <div class="col-12 col-md-6">
                                                <label class="form-label mb-1">Name</label>
                                                <input class="form-control" id="tName" disabled>
                                            </div>
                                            <div class="col-12 col-md-6">
                                                <label class="form-label mb-1">Ort (optional)</label>
                                                <input class="form-control" id="tLocation" disabled>
                                            </div>

                                            <div class="col-12 col-md-4">
                                                <label class="form-label mb-1">Turnierart</label>
                                                <select class="form-select" id="tType" disabled>
                                                    <option value="rebuy_addon">rebuy_addon</option>
                                                    <option value="rebuy">rebuy</option>
                                                    <option value="freezeout">freezeout</option>
                                                </select>
                                            </div>
                                            <div class="col-12 col-md-4">
                                                <label class="form-label mb-1">Buy-in (€)</label>
                                                <input class="form-control" type="number" step="0.01" id="tBuyIn" disabled>
                                            </div>
                                            <div class="col-12 col-md-4">
                                                <label class="form-label mb-1">Startstack</label>
                                                <input class="form-control" type="number" step="1" id="tStartStack" disabled>
                                            </div>
                                            <div class="col-12 col-md-4">
                                                <label class="form-label mb-1">Max Spieler</label>
                                                <input class="form-control" type="number" step="1" id="tMaxPlayers" disabled>
                                            </div>

                                            <div class="col-12 col-md-4">
                                                <label class="form-label mb-1">Rebuy aktiviert</label>
                                                <select class="form-select" id="rebuyEnabled" disabled>
                                                    <option value="true" selected>true</option>
                                                    <option value="false">false</option>
                                                </select>
                                            </div>
                                            <div class="col-12 col-md-4">
                                                <label class="form-label mb-1">Addon aktiviert</label>
                                                <select class="form-select" id="addonEnabled" disabled>
                                                    <option value="false" selected>false</option>
                                                    <option value="true">true</option>
                                                </select>
                                            </div>

                                            <div class="col-12 col-md-4">
                                                <label class="form-label mb-1">Rebuy (€)</label>
                                                <input class="form-control" type="number" step="0.01" id="rebuyEUR" disabled>
                                            </div>
                                            <div class="col-12 col-md-4">
                                                <label class="form-label mb-1">Addon (€)</label>
                                                <input class="form-control" type="number" step="0.01" id="addonEUR" disabled>
                                            </div>
                                            <div class="col-12 col-md-4">
                                                <label class="form-label mb-1">Rebuy bis Level #</label>
                                                <input class="form-control" type="number" step="1" id="rebuyUntilLevel" disabled>
                                            </div>
                                            <div class="col-12 col-md-4">
                                                <label class="form-label mb-1">Addon bis Level #</label>
                                                <input class="form-control" type="number" step="1" id="addonUntilLevel" disabled>
                                            </div>

                                            <div class="col-12 col-md-4">
                                                <label class="form-label mb-1">Rebuy Limit/Spieler (leer = ∞)</label>
                                                <input class="form-control" type="number" step="1" id="rebuyMaxPerPlayer" placeholder="z.B. 2" disabled>
                                            </div>
                                            <div class="col-12 col-md-4">
                                                <label class="form-label mb-1">Addon Limit/Spieler (leer = ∞)</label>
                                                <input class="form-control" type="number" step="1" id="addonMaxPerPlayer" placeholder="z.B. 1" disabled>
                                            </div>

                                            <div class="col-12 col-md-4">
                                                <label class="form-label mb-1">Display Theme</label>
                                                <select class="form-select" id="displayTheme" disabled>
                                                    <option value="default" selected>default</option>
                                                    <option value="classic">classic</option>
                                                    <option value="neon">neon</option>
                                                    <option value="carbon">carbon</option>
                                                </select>
                                            </div>

                                            <div class="col-12">
                                                <label class="form-label mb-1">Winners Overlay im Display</label>
                                                <select class="form-select" id="showWinnersOverlay" disabled>
                                                    <option value="true" selected>true</option>
                                                    <option value="false">false</option>
                                                </select>
                                            </div>

                                        </div>

                                        <div class="small text-danger mt-2" id="tMsg"></div>

                                        <hr class="border border-light border-opacity-10 my-3">

                                        <div class="small-muted">Display Link</div>
                                        <input class="form-control mono mt-1" id="displayLink" disabled>
                                    </div>
                                </div>

                                <div class="col-12 col-lg-5">
                                    <div class="card p-3 p-md-4 h-100">
                                        <h2 class="h5 text-white mb-1">Timer / Level Info</h2>
                                        <div class="small-muted mb-3">Countdown läuft lokal (kein Firestore-Polling).</div>

                                        <div class="row g-2">
                                            <div class="col-12">
                                                <div class="pill"><span class="small-muted">State</span><span class="fw-semibold mono" id="timerState">—</span></div>
                                            </div>
                                            <div class="col-12">
                                                <div class="pill"><span class="small-muted">Current Level #</span><span class="fw-semibold mono" id="currentLevelNo">—</span></div>
                                            </div>
                                            <div class="col-12">
                                                <div class="pill"><span class="small-muted">Level Label</span><span class="fw-semibold mono" id="currentLevelLabel">—</span></div>
                                            </div>
                                            <div class="col-12">
                                                <div class="pill"><span class="small-muted">Remaining</span><span class="fw-semibold mono" id="timerRemaining">—</span></div>
                                            </div>
                                            <div class="col-12">
                                                <div class="pill"><span class="small-muted">Next Transition</span><span class="fw-semibold mono" id="timerEndsAt">—</span></div>
                                            </div>
                                        </div>

                                        <div class="small text-danger mt-2" id="timerMsg"></div>
                                    </div>
                                </div>

                            </div>
                        </div>

                        <!-- PLAYERS -->
                        <div class="tab-pane fade" id="tabPlayers" role="tabpanel">
                            <div class="row g-3">
                                <div class="col-12 col-lg-5">
                                    <div class="card p-3 p-md-4 h-100">
                                        <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
                                            <div>
                                                <h2 class="h5 mb-0 text-white">Spieler hinzufügen</h2>
                                                <div class="small-muted">Dropdown zeigt nur User, die noch nicht im Turnier sind.</div>
                                            </div>
                                            <span class="badge badge-soft" id="usersCount">0</span>
                                        </div>

                                        <hr class="border border-light border-opacity-10 my-3">

                                        <input class="form-control form-control-sm mb-2" id="userSearch" placeholder="Suche (username / uid) …" disabled>

                                        <div class="dropdown w-100">
                                            <button class="btn btn-outline-light w-100 d-flex justify-content-between align-items-center"
                                                    id="btnUserDropdown" type="button" data-bs-toggle="dropdown" aria-expanded="false" disabled>
                                                <span id="userDropdownLabel">Spieler auswählen…</span>
                                                <span class="ms-2">▾</span>
                                            </button>
                                            <ul class="dropdown-menu w-100" id="userDropdownMenu" style="max-height: 360px; overflow:auto;">
                                                <li class="px-2 py-2 small-muted">Noch keine Daten.</li>
                                            </ul>
                                        </div>

                                        <div class="row g-2 mt-2">
                                            <div class="col-12 col-md-4">
                                                <label class="form-label mb-1">Stack (optional)</label>
                                                <input class="form-control" type="number" step="1" id="pStack" placeholder="leer = kein Stack" disabled>
                                            </div>

                                            <div class="col-12 col-md-4">
                                                <label class="form-label mb-1">Status</label>
                                                <select class="form-select" id="pStatus" disabled>
                                                    <option value="playing" selected>playing</option>
                                                    <option value="out">out</option>
                                                </select>
                                            </div>

                                            <div class="col-12 col-md-4">
                                                <label class="form-label mb-1">Entries</label>
                                                <input class="form-control" type="number" step="1" id="pEntries" value="1" disabled>
                                            </div>
                                            <div class="col-12 col-md-4">
                                                <label class="form-label mb-1">Rebuys</label>
                                                <input class="form-control" type="number" step="1" id="pRebuys" value="0" disabled>
                                            </div>
                                            <div class="col-12 col-md-4">
                                                <label class="form-label mb-1">Addons</label>
                                                <input class="form-control" type="number" step="1" id="pAddons" value="0" disabled>
                                            </div>

                                            <div class="col-12 col-md-4">
                                                <label class="form-label mb-1">Platz (optional)</label>
                                                <input class="form-control" type="number" step="1" id="pPlace" placeholder="z.B. 1" disabled>
                                            </div>

                                            <div class="col-12 d-grid">
                                                <button class="btn btn-primary" id="btnAddPlayer" type="button" disabled>Zum Turnier hinzufügen</button>
                                            </div>
                                            <div class="small text-danger mt-1" id="playerMsg"></div>

                                            <div class="small-muted mt-2">
                                                Hinweis: Table/Seat-Zuweisung erfolgt im Tab <span class="fw-semibold">Tische</span>.
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-12 col-lg-7">
                                    <div class="card p-3 p-md-4 h-100">
                                        <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
                                            <div>
                                                <h2 class="h5 mb-0 text-white">Spielerliste (Turnier)</h2>

                                            </div>
                                            <span class="badge badge-soft" id="playersCount">0</span>
                                        </div>

                                        <hr class="border border-light border-opacity-10 my-3">

                                        <div class="table-wrap table-responsive">
                                            <table class="table table-hover align-middle">
                                                <thead>
                                                <tr>
                                                    <th>Spieler</th>
                                                    <th class="text-end">Table</th>
                                                    <th class="text-end">Seat</th>
                                                    <th>Status</th>

                                                    <th class="text-end">Stack</th>
                                                    <th class="text-end">Rebuys</th>
                                                    <th class="text-end">Addons</th>
                                                    <th class="text-end">Platz</th>
                                                    <th class="text-end">Aktion</th>
                                                </tr>
                                                </thead>
                                                <tbody id="tbodyPlayers"></tbody>
                                            </table>
                                        </div>

                                        <div class="small text-danger mt-2" id="playersTableMsg"></div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- TABLES -->
                        <div class="tab-pane fade" id="tabTables" role="tabpanel">
                            <div class="row g-3">
                                <div class="col-12 col-lg-5">
                                    <div class="card p-3 p-md-4 h-100">
                                        <h2 class="h5 text-white mb-1">Multi-Table (optional)</h2>
                                        <div class="small-muted mb-3">
                                            Zuweisung von Spielern zu Tables/Seats erfolgt hier (automatisch oder manuell).
                                            Auto-Regel: Wenn >1 Admin aktiv ist, wird versucht pro aktivem Tisch mind. 1 Admin zu platzieren (falls möglich).
                                        </div>

                                        <div class="row g-2">
                                            <div class="col-12 col-md-6">
                                                <label class="form-label mb-1">Tables aktiv</label>
                                                <select class="form-select" id="tablesEnabled" disabled>
                                                    <option value="false" selected>false</option>
                                                    <option value="true">true</option>
                                                </select>
                                            </div>
                                            <div class="col-12 col-md-6">
                                                <label class="form-label mb-1">Anzahl Tables</label>
                                                <input class="form-control" type="number" step="1" id="tableCount" value="1" disabled>
                                            </div>
                                            <div class="col-12 col-md-6">
                                                <label class="form-label mb-1">Plätze pro Table</label>
                                                <input class="form-control" type="number" step="1" id="seatsPerTable" value="9" disabled>
                                            </div>
                                            <div class="col-12 col-md-6">
                                                <label class="form-label mb-1">Seat-Limit erzwingen</label>
                                                <select class="form-select" id="enforceSeats" disabled>
                                                    <option value="true" selected>true</option>
                                                    <option value="false">false</option>
                                                </select>
                                            </div>

                                            <div class="col-12">
                                                <hr class="border border-light border-opacity-10 my-2">
                                                <div class="small-muted">Automatik</div>
                                            </div>

                                            <div class="col-12 col-md-6">
                                                <label class="form-label mb-1">Auto-Zuweisung</label>
                                                <select class="form-select" id="autoAssignTables" disabled>
                                                    <option value="true" selected>true</option>
                                                    <option value="false">false</option>
                                                </select>
                                            </div>

                                            <div class="col-12 col-md-6">
                                                <label class="form-label mb-1">Min. Spieler für neuen Table</label>
                                                <input class="form-control" type="number" step="1" id="minPlayersPerTableForAdmin" value="3" disabled>
                                            </div>

                                            <div class="col-12 col-md-6">
                                                <label class="form-label mb-1">Dealer aus Admin-Team auto zuweisen</label>
                                                <select class="form-select" id="autoDealers" disabled>
                                                    <option value="true" selected>true</option>
                                                    <option value="false">false</option>
                                                </select>
                                            </div>

                                            <div class="col-12 d-flex gap-2 flex-wrap">
                                                <button class="btn btn-primary" id="btnAutoAssignNow" type="button" disabled>Jetzt automatisch verteilen</button>
                                                <button class="btn btn-outline-light" id="btnClearAssignments" type="button" disabled>Zuweisung löschen</button>
                                            </div>

                                            <div class="small text-danger mt-2" id="tablesMsg"></div>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-12 col-lg-7">
                                    <div class="card p-3 p-md-4 h-100">
                                        <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
                                            <div>
                                                <h2 class="h5 mb-0 text-white">Belegung</h2>
                                                <div class="small-muted" id="tablesHint">—</div>
                                            </div>

                                            <div class="d-flex gap-2 align-items-center flex-wrap">
                                                <div class="pill"><span class="small-muted">Admins</span><span class="fw-semibold mono" id="adminsCount">0</span></div>
                                                <div class="pill"><span class="small-muted">Active</span><span class="fw-semibold mono" id="activePlayersCount">0</span></div>
                                            </div>
                                        </div>

                                        <hr class="border border-light border-opacity-10 my-3">

                                        <div class="row g-3" id="tablesGrid"></div>

                                        <hr class="border border-light border-opacity-10 my-3">

                                        <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
                                            <div>
                                                <div class="fw-semibold text-white">Manuell zuweisen</div>
                                                <div class="small-muted">Keine festen Regeln (nur Automatik nutzt Regeln).</div>
                                            </div>
                                            <div class="d-flex gap-2 align-items-center flex-wrap">
                                                <select class="form-select form-select-sm" id="manualPlayerPick" style="min-width: 220px;" disabled>
                                                    <option value="">Spieler auswählen…</option>
                                                </select>
                                                <input class="form-control form-control-sm" id="manualTableNo" type="number" step="1" placeholder="Table" style="max-width:100px;" disabled>
                                                <input class="form-control form-control-sm" id="manualSeatNo" type="number" step="1" placeholder="Seat" style="max-width:100px;" disabled>
                                                <button class="btn btn-sm btn-outline-light" id="btnManualAssign" type="button" disabled>Zuweisen</button>
                                            </div>
                                        </div>

                                        <div class="small text-danger mt-2" id="manualMsg"></div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- STRUCTURE -->
                        <div class="tab-pane fade" id="tabStructure" role="tabpanel">
                            <div class="row g-3">
                                <div class="col-12 col-lg-6">
                                    <div class="card p-3 p-md-4 h-100">
                                        <h2 class="h5 text-white mb-1">Struktur automatisch erzeugen</h2>
                                        <div class="small-muted mb-3">
                                            Prozentualer Anstieg, aber gerundet in feste Schritte (z.B. 100, 150, 200 …).
                                            Überschreibt Level + Breaks. Danach kannst du alles manuell ändern.
                                        </div>

                                        <div class="row g-2">
                                            <div class="col-12 col-md-4">
                                                <label class="form-label mb-1">Level Dauer (Min)</label>
                                                <input class="form-control" type="number" step="1" id="genLevelMinutes" value="15" disabled>
                                            </div>
                                            <div class="col-12 col-md-4">
                                                <label class="form-label mb-1">Start SB</label>
                                                <input class="form-control" type="number" step="1" id="genStartSb" value="100" disabled>
                                            </div>
                                            <div class="col-12 col-md-4">
                                                <label class="form-label mb-1">Start BB</label>
                                                <input class="form-control" type="number" step="1" id="genStartBb" value="200" disabled>
                                            </div>
                                            <div class="col-12 col-md-4">
                                                <label class="form-label mb-1">Ante Start</label>
                                                <input class="form-control" type="number" step="1" id="genStartAnte" value="0" disabled>
                                            </div>
                                            <div class="col-12 col-md-4">
                                                <label class="form-label mb-1">Level Anzahl</label>
                                                <input class="form-control" type="number" step="1" id="genLevelsCount" value="16" disabled>
                                            </div>
                                            <div class="col-12 col-md-4">
                                                <label class="form-label mb-1">Steigerung</label>
                                                <select class="form-select" id="genGrowth" disabled>
                                                    <option value="1.25">+25%</option>
                                                    <option value="1.30" selected>+30%</option>
                                                    <option value="1.35">+35%</option>
                                                    <option value="1.40">+40%</option>
                                                </select>
                                            </div>

                                            <div class="col-12 col-md-6">
                                                <label class="form-label mb-1">Rundungsschritt</label>
                                                <select class="form-select" id="genRoundStep" disabled>
                                                    <option value="25">25</option>
                                                    <option value="50" selected>50</option>
                                                    <option value="100">100</option>
                                                </select>
                                            </div>

                                            <div class="col-12 col-md-6">
                                                <label class="form-label mb-1">BB = SB ×</label>
                                                <select class="form-select" id="genBbFactor" disabled>
                                                    <option value="2" selected>2</option>
                                                    <option value="3">3</option>
                                                </select>
                                            </div>

                                            <div class="col-12 col-md-6">
                                                <label class="form-label mb-1">Break alle N Level</label>
                                                <input class="form-control" type="number" step="1" id="genBreakEvery" value="4" disabled>
                                            </div>
                                            <div class="col-12 col-md-6">
                                                <label class="form-label mb-1">Break Dauer (Min)</label>
                                                <input class="form-control" type="number" step="1" id="genBreakMinutes" value="10" disabled>
                                            </div>

                                            <div class="col-12 d-grid mt-2">
                                                <button class="btn btn-primary" id="btnGenerateStructure" type="button" disabled>Struktur erzeugen (überschreibt)</button>
                                            </div>

                                            <div class="small text-danger mt-2" id="structureMsg"></div>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-12 col-lg-6">
                                    <div class="card p-3 p-md-4 h-100">
                                        <h2 class="h5 text-white mb-1">Levels manuell bearbeiten (live)</h2>
                                        <div class="small-muted mb-3">Ändere Typ/Min/SB/BB/Ante/Label. Alles wird sofort gespeichert.</div>

                                        <div class="table-wrap table-responsive">
                                            <table class="table table-hover align-middle">
                                                <thead>
                                                <tr>
                                                    <th>#</th>
                                                    <th>Typ</th>
                                                    <th class="text-end">Min</th>
                                                    <th class="text-end">SB</th>
                                                    <th class="text-end">BB</th>
                                                    <th class="text-end">Ante</th>
                                                    <th>Label</th>
                                                    <th class="text-end">Aktion</th>
                                                </tr>
                                                </thead>
                                                <tbody id="tbodyLevels"></tbody>
                                            </table>
                                        </div>

                                        <div class="small text-danger mt-2" id="levelsMsg"></div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- PAYOUTS -->
                        <div class="tab-pane fade" id="tabPayouts" role="tabpanel">
                            <div class="row g-3">
                                <div class="col-12 col-lg-5">
                                    <div class="card p-3 p-md-4 h-100">
                                        <h2 class="h5 text-white mb-1">Gewinne (Prozent)</h2>
                                        <div class="small-muted mb-3">
                                            Definiere nur die % pro Platz. Im Display werden Beträge automatisch aus dem Pool berechnet.
                                            Im Spieler-Tab kannst du Auszahlungen als Entry beim User speichern.
                                        </div>





                                        <div class="row g-2">
                                            <div class="col-6">
                                                <label class="form-label mb-1">Platz</label>
                                                <input class="form-control" type="number" step="1" id="payoutPlace" value="1" disabled>
                                            </div>
                                            <div class="col-6">
                                                <label class="form-label mb-1">Prozent (%)</label>
                                                <input class="form-control" type="number" step="0.01" id="payoutPercent" value="0" disabled>
                                            </div>
                                            <div class="col-12 d-grid">
                                                <button class="btn btn-primary" id="btnAddPayoutPercent" type="button" disabled>Prozent hinzufügen</button>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-12 col-lg-7">
                                    <div class="card p-3 p-md-4 h-100">
                                        <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
                                            <div>
                                                <h2 class="h5 mb-0 text-white">Payout-Struktur (live)</h2>
                                                <div class="small-muted">Editieren oder löschen.</div>
                                            </div>
                                            <span class="badge badge-soft" id="payoutsCount">0</span>
                                        </div>

                                        <hr class="border border-light border-opacity-10 my-3">

                                        <div class="table-wrap table-responsive">
                                            <table class="table table-hover align-middle">
                                                <thead>
                                                <tr>
                                                    <th class="text-end">#</th>
                                                    <th class="text-end">%</th>
                                                    <th class="text-end">Aktion</th>
                                                </tr>
                                                </thead>
                                                <tbody id="tbodyPayouts"></tbody>
                                            </table>
                                        </div>

                                        <div class="small text-danger mt-2" id="payoutsTableMsg"></div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- DANGER -->
                        <div class="tab-pane fade" id="tabDanger" role="tabpanel">
                            <div class="card p-3 p-md-4 danger-zone">
                                <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
                                    <div>
                                        <div class="fw-semibold text-white">Danger Zone</div>
                                        <div class="small-muted">Reset löscht players/levels/events. Delete löscht Turnier komplett.</div>
                                    </div>
                                    <div class="d-flex gap-2 flex-wrap">
                                        <button class="btn btn-outline-light" id="btnResetTournament" type="button" disabled>Reset</button>
                                        <button class="btn btn-outline-danger" id="btnDeleteTournament" type="button" disabled>Löschen</button>
                                    </div>
                                </div>
                                <div class="small text-danger mt-2" id="dangerMsg"></div>
                            </div>
                        </div>

                    </div><!-- tab-content -->
                </div>
            </div>
        </div>

    </div><!-- /appArea -->
</main>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js";
    import {
        getAuth, onAuthStateChanged, signOut,
        signInWithEmailAndPassword,
        GoogleAuthProvider, signInWithPopup
    } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-auth.js";
    import {
        getFirestore,
        doc, getDoc, setDoc, updateDoc, deleteDoc,
        collection, getDocs, addDoc, onSnapshot, query, orderBy,
        serverTimestamp, writeBatch, runTransaction, increment
    } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-firestore.js";

    const firebaseConfig = {
        apiKey: "AIzaSyASN7beVlrbMtUwMr4BKfSx1EmUQZJAfNk",
        authDomain: "zentrale-ee675.firebaseapp.com",
        projectId: "zentrale-ee675",
        storageBucket: "zentrale-ee675.firebasestorage.app",
        messagingSenderId: "1091342474994",
        appId: "1:1091342474994:web:29ff79685bbd4e5077fa6b",
        measurementId: "G-S805TDBQCQ"
    };
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // DOM (Top)
    const authStatus = document.getElementById("authStatus");
    const btnLogout = document.getElementById("btnLogout");
    const btnOpenDisplay = document.getElementById("btnOpenDisplay");

    const loginArea = document.getElementById("loginArea");
    const appArea = document.getElementById("appArea");
    const loginForm = document.getElementById("loginForm");
    const loginEmail = document.getElementById("loginEmail");
    const loginPassword = document.getElementById("loginPassword");
    const btnGoogle = document.getElementById("btnGoogle");
    const loginMsg = document.getElementById("loginMsg");
    const whoAmI = document.getElementById("whoAmI");

    const tbodyTournaments = document.getElementById("tbodyTournaments");
    const tournamentsMsg = document.getElementById("tournamentsMsg");

    const newName = document.getElementById("newName");
    const newType = document.getElementById("newType");
    const newBuyIn = document.getElementById("newBuyIn");
    const newStack = document.getElementById("newStack");
    const newMaxPlayers = document.getElementById("newMaxPlayers");
    const btnCreateTournament = document.getElementById("btnCreateTournament");
    const createMsg = document.getElementById("createMsg");

    const tidBadge = document.getElementById("tidBadge");
    const statusBadge = document.getElementById("statusBadge");
    const displayLink = document.getElementById("displayLink");

    const tabPayoutBtn = document.getElementById("tabPayoutBtn");
    const tbodyPayout = document.getElementById("tbodyPayout");
    const btnBookPayouts = document.getElementById("btnBookPayouts");


    // Controls fields
    const tName = document.getElementById("tName");
    const tLocation = document.getElementById("tLocation");
    const tType = document.getElementById("tType");
    const tBuyIn = document.getElementById("tBuyIn");
    const tStartStack = document.getElementById("tStartStack");
    const tMaxPlayers = document.getElementById("tMaxPlayers");

    const rebuyEnabled = document.getElementById("rebuyEnabled");
    const addonEnabled = document.getElementById("addonEnabled");
    const rebuyEUR = document.getElementById("rebuyEUR");
    const addonEUR = document.getElementById("addonEUR");
    const rebuyUntilLevel = document.getElementById("rebuyUntilLevel");
    const addonUntilLevel = document.getElementById("addonUntilLevel");
    const rebuyMaxPerPlayer = document.getElementById("rebuyMaxPerPlayer");
    const addonMaxPerPlayer = document.getElementById("addonMaxPerPlayer");

    const displayTheme = document.getElementById("displayTheme");
    const showWinnersOverlay = document.getElementById("showWinnersOverlay");
    const tMsg = document.getElementById("tMsg");

    // Timer info
    const btnStart = document.getElementById("btnStart");
    const btnPause = document.getElementById("btnPause");
    const btnBreak = document.getElementById("btnBreak");
    const btnNext = document.getElementById("btnNext");
    const btnFinish = document.getElementById("btnFinish");
    const controlsMsg = document.getElementById("controlsMsg");
    const timerState = document.getElementById("timerState");
    const currentLevelNo = document.getElementById("currentLevelNo");
    const currentLevelLabel = document.getElementById("currentLevelLabel");
    const timerRemaining = document.getElementById("timerRemaining");
    const timerEndsAt = document.getElementById("timerEndsAt");
    const timerMsg = document.getElementById("timerMsg");

    // Players tab
    const usersCount = document.getElementById("usersCount");
    const userSearch = document.getElementById("userSearch");
    const btnUserDropdown = document.getElementById("btnUserDropdown");
    const userDropdownMenu = document.getElementById("userDropdownMenu");
    const userDropdownLabel = document.getElementById("userDropdownLabel");

    const pStack = document.getElementById("pStack");
    const pStatus = document.getElementById("pStatus");
    const pEntries = document.getElementById("pEntries");
    const pRebuys = document.getElementById("pRebuys");
    const pAddons = document.getElementById("pAddons");
    const pPlace = document.getElementById("pPlace");
    const btnAddPlayer = document.getElementById("btnAddPlayer");
    const playerMsg = document.getElementById("playerMsg");

    const playersCount = document.getElementById("playersCount");
    const tbodyPlayers = document.getElementById("tbodyPlayers");
    const playersTableMsg = document.getElementById("playersTableMsg");

    // Tables tab
    const tablesEnabled = document.getElementById("tablesEnabled");
    const tableCount = document.getElementById("tableCount");
    const seatsPerTable = document.getElementById("seatsPerTable");
    const enforceSeats = document.getElementById("enforceSeats");
    const autoAssignTables = document.getElementById("autoAssignTables");
    const autoDealers = document.getElementById("autoDealers");
    const minPlayersPerTableForAdmin = document.getElementById("minPlayersPerTableForAdmin");
    const btnAutoAssignNow = document.getElementById("btnAutoAssignNow");
    const btnClearAssignments = document.getElementById("btnClearAssignments");
    const tablesMsg = document.getElementById("tablesMsg");
    const tablesHint = document.getElementById("tablesHint");
    const tablesGrid = document.getElementById("tablesGrid");
    const adminsCount = document.getElementById("adminsCount");
    const activePlayersCount = document.getElementById("activePlayersCount");
    const manualPlayerPick = document.getElementById("manualPlayerPick");
    const manualTableNo = document.getElementById("manualTableNo");
    const manualSeatNo = document.getElementById("manualSeatNo");
    const btnManualAssign = document.getElementById("btnManualAssign");
    const manualMsg = document.getElementById("manualMsg");

    // Structure
    const genLevelMinutes = document.getElementById("genLevelMinutes");
    const genStartSb = document.getElementById("genStartSb");
    const genStartBb = document.getElementById("genStartBb");
    const genStartAnte = document.getElementById("genStartAnte");
    const genLevelsCount = document.getElementById("genLevelsCount");
    const genGrowth = document.getElementById("genGrowth");
    const genBreakEvery = document.getElementById("genBreakEvery");
    const genBreakMinutes = document.getElementById("genBreakMinutes");
    const genRoundStep = document.getElementById("genRoundStep");
    const genBbFactor = document.getElementById("genBbFactor");
    const btnGenerateStructure = document.getElementById("btnGenerateStructure");
    const structureMsg = document.getElementById("structureMsg");
    const tbodyLevels = document.getElementById("tbodyLevels");
    const levelsMsg = document.getElementById("levelsMsg");

    // Payouts
    const payoutPlace = document.getElementById("payoutPlace");
    const payoutPercent = document.getElementById("payoutPercent");
    const btnAddPayoutPercent = document.getElementById("btnAddPayoutPercent");
    const payoutMsg = document.getElementById("payoutMsg");
    const payoutsCount = document.getElementById("payoutsCount");
    const tbodyPayouts = document.getElementById("tbodyPayouts");
    const payoutsTableMsg = document.getElementById("payoutsTableMsg");

    // Danger
    const btnResetTournament = document.getElementById("btnResetTournament");
    const btnDeleteTournament = document.getElementById("btnDeleteTournament");
    const dangerMsg = document.getElementById("dangerMsg");

    // Helpers
    function escapeHtml(str){
        return (str ?? "").toString()
            .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
            .replaceAll('"',"&quot;").replaceAll("'","&#039;");
    }
    function defaultAvatarDataUrl(){
        const svg = `
      <svg xmlns="http://www.w3.org/2000/svg" width="128" height="128" viewBox="0 0 128 128">
        <defs><linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
          <stop offset="0" stop-color="#334155"/><stop offset="1" stop-color="#0f172a"/>
        </linearGradient></defs>
        <rect width="128" height="128" rx="64" fill="url(#g)"/>
        <circle cx="64" cy="52" r="22" fill="#e2e8f0" opacity="0.95"/>
        <path d="M22,118c8-24,30-34,42-34s34,10,42,34" fill="#e2e8f0" opacity="0.95"/>
      </svg>
    `.trim();
        return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
    }
    function msToClock(ms){
        const s = Math.max(0, Math.floor(ms/1000));
        const mm = String(Math.floor(s/60)).padStart(2,"0");
        const ss = String(s%60).padStart(2,"0");
        return `${mm}:${ss}`;
    }
    function stateDotClass(s){
        const v = String(s||"setup");
        if(v==="running") return "s-running";
        if(v==="paused") return "s-paused";
        if(v==="break") return "s-break";
        if(v==="finished") return "s-finished";
        return "s-setup";
    }
    function setUI(loggedIn){
        loginArea.classList.toggle("d-none", loggedIn);
        appArea.classList.toggle("d-none", !loggedIn);
        btnLogout.classList.toggle("d-none", !loggedIn);
        authStatus.textContent = loggedIn ? "Eingeloggt" : "Nicht eingeloggt";
    }
    function setDisplayLink(tid){
        const url = new URL("./display.html", window.location.href);
        url.searchParams.set("tid", tid);
        displayLink.value = url.toString();
        btnOpenDisplay.href = url.toString();
        btnOpenDisplay.classList.toggle("d-none", !tid);
    }
    function enableTournamentWrite(enabled){
        for(const el of [
            btnStart, btnPause, btnBreak, btnNext, btnFinish,
            tName, tLocation, tType, tBuyIn, tStartStack, tMaxPlayers,
            rebuyEnabled, addonEnabled, rebuyEUR, addonEUR, rebuyUntilLevel, addonUntilLevel,
            rebuyMaxPerPlayer, addonMaxPerPlayer,
            displayTheme, showWinnersOverlay,
            userSearch, btnUserDropdown, pStack, pStatus, pRebuys, pAddons, pPlace, btnAddPlayer,
            tablesEnabled, tableCount, seatsPerTable, enforceSeats, autoAssignTables, autoDealers, minPlayersPerTableForAdmin,
            btnAutoAssignNow, btnClearAssignments, manualPlayerPick, manualTableNo, manualSeatNo, btnManualAssign,
            genLevelMinutes, genStartSb, genStartBb, genStartAnte, genLevelsCount, genGrowth, genBreakEvery, genBreakMinutes, genRoundStep, genBbFactor, btnGenerateStructure,
            payoutPlace, payoutPercent, btnAddPayoutPercent,
            btnResetTournament, btnDeleteTournament
        ]) el.disabled = !enabled;
    }
    function nowMs(){ return Date.now(); }
    function todayISO(){ return new Date().toISOString().slice(0,10); }

    function getMoneySettings(){
        const t = tournamentCache || {};
        const s = t.settings || {};

        const buyInEUR = Number(t.buyInEUR || 0);

        // payoutPercents: [{place, percent}] -> Map
        const payoutMap = new Map();
        if(Array.isArray(s.payoutPercents)){
            for(const row of s.payoutPercents){
                const pl = Number(row?.place || 0);
                const pc = Number(row?.percent || 0);
                if(pl > 0 && pc >= 0) payoutMap.set(pl, pc);
            }
        }

        return {
            buyInEUR,
            rebuyEnabled: !!s.rebuyEnabled,
            addonEnabled: !!s.addonEnabled,
            rebuyEUR: Number(s.rebuyEUR ?? buyInEUR ?? 0),
            addonEUR: Number(s.addonEUR ?? buyInEUR ?? 0),
            payoutMap
        };
    }


    function getPlayerCostsEUR(p){
        const ms = getMoneySettings();

        const entries = Math.max(0, Number(p?.entries || 0));
        const rebuys  = ms.rebuyEnabled ? Math.max(0, Number(p?.rebuys || 0)) : 0;
        const addons  = ms.addonEnabled ? Math.max(0, Number(p?.addons || 0)) : 0;

        const cost =
            (entries * ms.buyInEUR) +
            (rebuys  * ms.rebuyEUR) +
            (addons  * ms.addonEUR);

        return Math.round(cost * 100) / 100;
    }


    function computePrizePoolEUR(){
        return Math.round(
            (playersCache || []).reduce((sum, p) => sum + getPlayerCostsEUR(p), 0) * 100
        ) / 100;
    }

    function getGrossWinEURForPlace(place){
        const ms = getMoneySettings();
        const pool = computePrizePoolEUR();

        const pl = Number(place || 0);
        if(!Number.isFinite(pl) || pl <= 0) return 0;

        const pct = Number(ms.payoutMap.get(pl) || 0);
        const gross = pool * (pct / 100);

        return Math.round(gross * 100) / 100;
    }


    // WICHTIG: Diese Funktion wird überall verwendet (Anzeige + Button “Auf Spieler berechnen”)
    function getPlayerNetEUR(p){
        const place = Number(p?.place || 0);
        const gross = getGrossWinEURForPlace(place);
        const cost = getPlayerCostsEUR(p);
        const net = gross - cost;
        return Math.round(net * 100) / 100;
    }

    async function autoAssignPlaces(){
        if(!currentTid) return;

        // Kandidaten: OUT-Spieler
        const outPlayers = (playersCache || [])
            .filter(p => (p.status||"playing")==="out")
            .slice();

        if(outPlayers.length === 0) return;

        // Sortierung: wer früher OUT ging -> schlechterer Platz
        // früh OUT => größere place (z.B. 20.)
        outPlayers.sort((a,b) => {
            const ta = a.outAt?.toMillis ? a.outAt.toMillis() : Number(a.outAt || 0);
            const tb = b.outAt?.toMillis ? b.outAt.toMillis() : Number(b.outAt || 0);
            return ta - tb; // zuerst out
        });

        // Beispiel: 20 Spieler total, 1. ist Gewinner
        const total = (playersCache || []).length;
        const b = writeBatch(db);

        // outPlayers[0] war zuerst out => bekommt Platz total
        // outPlayers[last] war zuletzt out => bekommt Platz 2 (wenn noch 1 Spieler „drin“ bleibt)
        for(let i=0;i<outPlayers.length;i++){
            const p = outPlayers[i];
            const place = total - i;
            b.update(doc(db, "tournaments", currentTid, "players", p.id), { place, updatedAt: serverTimestamp() });
        }

        await b.commit();
    }



    function amountClass(amount){
        amount = Number(amount || 0);
        if (amount > 0) return "amount-pos";
        if (amount < 0) return "amount-neg";
        return "amount-zero";
    }
    function formatEUR(amount){
        const n = Number(amount || 0);
        return new Intl.NumberFormat("de-DE", {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        }).format(n) + " €";
    }
    // Deterministic RNG to avoid oscillation
    function hash32(str){
        let h = 2166136261 >>> 0;
        for(let i=0;i<str.length;i++){
            h ^= str.charCodeAt(i);
            h = Math.imul(h, 16777619);
        }
        return h >>> 0;
    }
    function mulberry32(seed){
        let t = seed >>> 0;
        return function(){
            t += 0x6D2B79F5;
            let r = Math.imul(t ^ (t >>> 15), 1 | t);
            r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
            return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
        };
    }
    function seededShuffle(arr, seed){
        const a = arr.slice();
        const rnd = mulberry32(seed);
        for(let i=a.length-1;i>0;i--){
            const j = Math.floor(rnd()*(i+1));
            [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
    }

    // Auth
    loginForm.addEventListener("submit", async (e) => {
        e.preventDefault();
        loginMsg.textContent = "";
        try{
            await signInWithEmailAndPassword(auth, loginEmail.value.trim(), loginPassword.value);
        }catch(err){
            loginMsg.textContent = err?.message || "Login fehlgeschlagen.";
        }
    });
    btnGoogle.addEventListener("click", async () => {
        loginMsg.textContent = "";
        try{
            const provider = new GoogleAuthProvider();
            provider.setCustomParameters({ prompt: "select_account" });
            await signInWithPopup(auth, provider);
        }catch(err){
            loginMsg.textContent = err?.message || "Google Login fehlgeschlagen.";
        }
    });
    btnLogout.addEventListener("click", async () => { await signOut(auth); });

    // State
    let currentUser = null;
    let currentTid = null;

    let tournamentCache = null;
    let levelsCache = [];
    let playersCache = [];
    let usersCache = [];
    let selectedUser = null;

    // Admins are defined by collection: /admins/{uid}
    let adminUidSet = new Set();

    // Unsubs
    let unsubTournaments = null;
    let unsubTournament = null;
    let unsubUsers = null;
    let unsubPlayers = null;
    let unsubLevels = null;
    let unsubAdmins = null;

    // Anti-loop for auto assign
    let lastAutoAssignFingerprintSeen = null;
    let lastPlayersMembershipFingerprint = null;

    // ===== Timer scheduler: no constant Firestore writes =====
    let transitionTimeout = null;
    let uiInterval = null;

    function clearTimerScheduler(){
        if(transitionTimeout){ clearTimeout(transitionTimeout); transitionTimeout = null; }
        if(uiInterval){ clearInterval(uiInterval); uiInterval = null; }
    }

    function stopTournamentListeners(){
        clearTimerScheduler();
        if(unsubTournament){ unsubTournament(); unsubTournament=null; }
        if(unsubPlayers){ unsubPlayers(); unsubPlayers=null; }
        if(unsubLevels){ unsubLevels(); unsubLevels=null; }
        tournamentCache = null;
        levelsCache = [];
        playersCache = [];
        tbodyPlayers.innerHTML = "";
        tbodyLevels.innerHTML = "";
        tbodyPayouts.innerHTML = "";
        playersCount.textContent = "0";
        payoutsCount.textContent = "0";
        timerState.textContent = "—";
        currentLevelNo.textContent = "—";
        currentLevelLabel.textContent = "—";
        timerRemaining.textContent = "—";
        timerEndsAt.textContent = "—";
        tablesGrid.innerHTML = "";
        tablesHint.textContent = "—";
        adminsCount.textContent = "0";
        activePlayersCount.textContent = "0";
        manualPlayerPick.innerHTML = `<option value="">Spieler auswählen…</option>`;
        lastAutoAssignFingerprintSeen = null;
        lastPlayersMembershipFingerprint = null;
    }

    function playersIdSet(){ return new Set(playersCache.map(p => p.id)); }

    function renderUsersDropdown(){
        const q = (userSearch.value || "").trim().toLowerCase();
        const inTournament = playersIdSet();

        const filtered = usersCache
            .filter(u => !!u.username)
            .filter(u => !currentTid || !inTournament.has(u.uid))
            .filter(u => !q || String(u.username||"").toLowerCase().includes(q) || String(u.uid||"").toLowerCase().includes(q));

        usersCount.textContent = String(filtered.length);

        if(filtered.length === 0){
            userDropdownMenu.innerHTML = `<li class="px-2 py-2 small-muted">Keine passenden Spieler (oder alle bereits hinzugefügt).</li>`;
            return;
        }

        userDropdownMenu.innerHTML = filtered.map(u => {
            const photo = u.photoDataUrl || defaultAvatarDataUrl();
            const isAdmin = adminUidSet.has(u.uid);
            return `
        <li>
          <button class="dropdown-item" type="button" data-pick-user="${escapeHtml(u.uid)}">
            <div class="player-item">
              <img class="avatar" src="${escapeHtml(photo)}" alt="Avatar">
              <div class="flex-grow-1">
                <div class="pname">${escapeHtml(u.username)} ${isAdmin ? '<span class="badge badge-soft ms-1">ADMIN</span>' : ''}</div>
                <div class="puid mono">${escapeHtml(u.uid)}</div>
              </div>
            </div>
          </button>
        </li>
      `;
        }).join("");
    }
    userSearch.addEventListener("input", renderUsersDropdown);

    document.addEventListener("click", (e) => {
        const btn = e.target.closest("button[data-pick-user]");
        if(!btn) return;
        const uid = btn.getAttribute("data-pick-user");
        const u = usersCache.find(x => x.uid === uid);
        if(!u) return;
        selectedUser = { uid: u.uid, username: u.username, photoDataUrl: u.photoDataUrl || null };
        userDropdownLabel.textContent = u.username;
        playerMsg.textContent = "";
    });

    function renderTournamentList(items){
        tbodyTournaments.innerHTML = items.map(t => {
            const s = String(t.status || "setup");
            const dot = `<span class="state-dot ${stateDotClass(s)}"></span>`;
            const n = t.name || "(ohne Name)";
            const pcount = Number(t.playersCount || 0);

            return `
        <tr>
          <td>${dot}<span class="badge badge-soft">${escapeHtml(s)}</span></td>
          <td>
            <div class="fw-semibold">${escapeHtml(n)}</div>
            <div class="small-muted mono" style="color: black;">${escapeHtml(t.tid)}</div>
          </td>
          <td class="text-end">${escapeHtml(String(pcount))}</td>
          <td class="text-end">
            <button class="btn btn-sm btn-outline-primary" data-open-tid="${escapeHtml(t.tid)}" type="button">Öffnen</button>
            <button class="btn btn-sm btn-outline-danger ms-1" data-del-tid="${escapeHtml(t.tid)}" type="button">Löschen</button>
          </td>
        </tr>
      `;
        }).join("") || `<tr><td colspan="4" class="small-muted">Keine Turniere.</td></tr>`;
    }

    document.addEventListener("click", async (e) => {
        const openBtn = e.target.closest("button[data-open-tid]");
        if(openBtn){
            const tid = openBtn.getAttribute("data-open-tid");
            if(!tid) return;
            await openTournament(tid);
        }

        const delBtn = e.target.closest("button[data-del-tid]");
        if(delBtn){
            const tid = delBtn.getAttribute("data-del-tid");
            if(!tid) return;
            if(!confirm("Turnier wirklich löschen? (inkl. Subcollections)")) return;

            try{
                await deleteSubcollectionDocs(tid, "players");
                await deleteSubcollectionDocs(tid, "levels");
                await deleteSubcollectionDocs(tid, "events");
                await deleteDoc(doc(db, "tournaments", tid));

                if(currentTid === tid){
                    await openTournament(null);
                }
            }catch(err){
                tournamentsMsg.textContent = err?.message || "Löschen fehlgeschlagen.";
            }
        }
    });

    function startTournamentsListener(){
        if(unsubTournaments) unsubTournaments();
        unsubTournaments = onSnapshot(
            query(collection(db, "tournaments"), orderBy("updatedAt", "desc")),
            (snap) => {
                tournamentsMsg.textContent = "";
                const items = snap.docs.map(d => {
                    const data = d.data() || {};
                    return {
                        tid: d.id,
                        name: data.name || "",
                        status: data.status || "setup",
                        playersCount: Number(data.playersCount || 0)
                    };
                });
                renderTournamentList(items);
            },
            (err) => { tournamentsMsg.textContent = err?.message || "Fehler beim Laden der Turniere."; }
        );
    }

    function startUsersListener(){
        if(unsubUsers) unsubUsers();
        unsubUsers = onSnapshot(
            query(collection(db, "users"), orderBy("username", "asc")),
            (snap) => {
                usersCache = snap.docs.map(d => ({ uid: d.id, ...d.data() }));
                renderUsersDropdown();
                renderTablesUi();
            },
            (err) => {
                userDropdownMenu.innerHTML = `<li class="px-2 py-2 text-danger">${escapeHtml(err.message || "Fehler beim Laden der User.")}</li>`;
            }
        );
    }

    // Admins listener: /admins/{uid}
    function startAdminsListener(){
        if(unsubAdmins) unsubAdmins();
        unsubAdmins = onSnapshot(
            query(collection(db, "admins"), orderBy("__name__", "asc")),
            (snap) => {
                adminUidSet = new Set(snap.docs.map(d => d.id));
                renderUsersDropdown();
                renderTablesUi();
            },
            (err) => { console.warn("Admins load error:", err?.message); }
        );
    }
    function isAdminUid(uid){ return adminUidSet.has(uid); }
    function getAdminUids(){ return Array.from(adminUidSet.values()); }

    // Create tournament
    btnCreateTournament.addEventListener("click", async () => {
        createMsg.textContent = "";
        if(!currentUser){ createMsg.textContent = "Nicht eingeloggt."; return; }

        const name = (newName.value || "").trim() || "Poker Turnier";
        const type = newType.value || "rebuy_addon";
        const buyInEURv = Math.round(Number(newBuyIn.value || 0) * 100) / 100;
        const startStackv = Math.max(0, Math.round(Number(newStack.value || 0)));
        const maxPlayersv = Math.max(1, Math.round(Number(newMaxPlayers.value || 0)));

        try{
            const tid = Math.random().toString(36).slice(2, 10) + Math.random().toString(36).slice(2, 6);

            await setDoc(doc(db, "tournaments", tid), {
                ownerUid: currentUser.uid,
                name,
                type,
                status: "setup",
                buyInEUR: buyInEURv,
                startStack: startStackv,
                maxPlayers: maxPlayersv,
                location: "",
                playersCount: 0,

                currentLevelIndex: 1,
                currentLevelType: "level",
                currentLevelLabel: "",

                // schedule-based timer
                timer: { state:"setup", scheduleStartMs:0, pausedAtMs:0, totalPausedMs:0 },

                settings: {
                    rebuyEnabled: true,
                    addonEnabled: false,
                    rebuyEUR: buyInEURv,
                    addonEUR: buyInEURv,
                    rebuyUntilLevel: 8,
                    addonUntilLevel: 8,
                    rebuyMaxPerPlayer: null,
                    addonMaxPerPlayer: null,

                    payoutPercents: [],
                    showWinnersOverlay: true,
                    displayTheme: "default",

                    tables: {
                        enabled: false,
                        tableCount: 1,
                        seatsPerTable: 9,
                        enforceSeats: true,
                        autoAssign: true,
                        autoDealers: true,
                        minPlayersForNewTable: 3,
                        dealers: {},
                        autoAssignSalt: null,
                        lastAssignedFingerprint: null
                    }
                },

                createdAt: serverTimestamp(),
                updatedAt: serverTimestamp()
            }, { merge: false });

            await openTournament(tid);
        }catch(err){
            createMsg.textContent = err?.message || "Erstellen fehlgeschlagen.";
        }
    });

    // Live patch tournament doc fields (debounced)
    let saveTimer = null;
    async function schedulePatch(patch){
        if(!currentTid) return;
        clearTimeout(saveTimer);
        saveTimer = setTimeout(async () => {
            try{
                await updateDoc(doc(db, "tournaments", currentTid), { ...patch, updatedAt: serverTimestamp() });
                tMsg.textContent = "";
            }catch(err){
                tMsg.textContent = err?.message || "Speichern fehlgeschlagen.";
            }
        }, 250);
    }
    async function scheduleSettingsPatch(settingsPatch){
        if(!currentTid) return;
        clearTimeout(saveTimer);
        saveTimer = setTimeout(async () => {
            try{
                const cur = (tournamentCache?.settings) || {};
                await updateDoc(doc(db, "tournaments", currentTid), { settings: { ...cur, ...settingsPatch }, updatedAt: serverTimestamp() });
                tMsg.textContent = "";
            }catch(err){
                tMsg.textContent = err?.message || "Speichern fehlgeschlagen.";
            }
        }, 250);
    }

    function patchTables(partial){
        const cur = (tournamentCache?.settings?.tables) || {};
        scheduleSettingsPatch({ tables: { ...cur, ...partial } });
    }

    // Controls patch
    for(const [el, key, cast] of [
        [tName, "name", v => String(v||"")],
        [tLocation, "location", v => String(v||"")],
        [tType, "type", v => String(v||"rebuy")],
        [tBuyIn, "buyInEUR", v => Math.round(Number(v||0)*100)/100],
        [tStartStack, "startStack", v => Math.max(0, Math.round(Number(v||0)))],
        [tMaxPlayers, "maxPlayers", v => Math.max(1, Math.round(Number(v||0)))]
    ]){
        el.addEventListener("input", () => schedulePatch({ [key]: cast(el.value) }));
        el.addEventListener("change", () => schedulePatch({ [key]: cast(el.value) }));
    }

    rebuyEnabled.addEventListener("change", () => scheduleSettingsPatch({ rebuyEnabled: rebuyEnabled.value === "true" }));
    addonEnabled.addEventListener("change", () => scheduleSettingsPatch({ addonEnabled: addonEnabled.value === "true" }));
    rebuyEUR.addEventListener("input", () => scheduleSettingsPatch({ rebuyEUR: Math.round(Number(rebuyEUR.value||0)*100)/100 }));
    addonEUR.addEventListener("input", () => scheduleSettingsPatch({ addonEUR: Math.round(Number(addonEUR.value||0)*100)/100 }));
    rebuyUntilLevel.addEventListener("input", () => scheduleSettingsPatch({ rebuyUntilLevel: Math.max(1, Math.round(Number(rebuyUntilLevel.value||1))) }));
    addonUntilLevel.addEventListener("input", () => scheduleSettingsPatch({ addonUntilLevel: Math.max(1, Math.round(Number(addonUntilLevel.value||1))) }));

    rebuyMaxPerPlayer.addEventListener("input", () => {
        const v = rebuyMaxPerPlayer.value.trim();
        scheduleSettingsPatch({ rebuyMaxPerPlayer: v === "" ? null : Math.max(0, Math.round(Number(v||0))) });
    });
    addonMaxPerPlayer.addEventListener("input", () => {
        const v = addonMaxPerPlayer.value.trim();
        scheduleSettingsPatch({ addonMaxPerPlayer: v === "" ? null : Math.max(0, Math.round(Number(v||0))) });
    });

    displayTheme.addEventListener("change", () => scheduleSettingsPatch({ displayTheme: displayTheme.value }));
    showWinnersOverlay.addEventListener("change", () => scheduleSettingsPatch({ showWinnersOverlay: showWinnersOverlay.value === "true" }));

    // Tables settings nested
    tablesEnabled.addEventListener("change", () => patchTables({ enabled: tablesEnabled.value === "true" }));
    tableCount.addEventListener("input", () => patchTables({ tableCount: Math.max(1, Math.round(Number(tableCount.value||1))) }));
    seatsPerTable.addEventListener("input", () => patchTables({ seatsPerTable: Math.max(1, Math.round(Number(seatsPerTable.value||9))) }));
    enforceSeats.addEventListener("change", () => patchTables({ enforceSeats: enforceSeats.value === "true" }));
    autoAssignTables.addEventListener("change", () => patchTables({ autoAssign: autoAssignTables.value === "true" }));
    autoDealers.addEventListener("change", () => patchTables({ autoDealers: autoDealers.value === "true" }));
    minPlayersPerTableForAdmin.addEventListener("input", () => patchTables({ minPlayersForNewTable: Math.max(1, Math.round(Number(minPlayersPerTableForAdmin.value||3))) }));

    // ========== TIMER (no polling writes) ==========
    function getLevelsOrdered(){
        return levelsCache
            .slice()
            .sort((a,b)=> Number(a.index||0) - Number(b.index||0))
            .map(l => ({
                index: Number(l.index||0),
                type: String(l.type||"level"),
                minutes: Math.max(0, Number(l.minutes||0)),
                label: String(l.label||"")
            }));
    }

    function computeScheduleAt(tdata, atMs){
        const timer = tdata?.timer || {};
        const stateStored = String(timer.state||"setup");

        if(stateStored === "finished"){
            return { state:"finished", currentLevelIndex:Number(tdata.currentLevelIndex||1), currentLevelType:String(tdata.currentLevelType||"level"), currentLevelLabel:String(tdata.currentLevelLabel||""), remainingMs:0, transitionAtMs:0 };
        }

        const scheduleStartMs = Number(timer.scheduleStartMs||0);
        const pausedAtMs = Number(timer.pausedAtMs||0);
        const totalPausedMs = Number(timer.totalPausedMs||0);

        const levels = getLevelsOrdered();
        if(!levels.length || !scheduleStartMs){
            return {
                state: stateStored,
                currentLevelIndex: Number(tdata.currentLevelIndex||1),
                currentLevelType: String(tdata.currentLevelType||"level"),
                currentLevelLabel: String(tdata.currentLevelLabel||""),
                remainingMs: 0,
                transitionAtMs: 0
            };
        }

        const effectiveNow = (stateStored === "paused" && pausedAtMs) ? pausedAtMs : atMs;
        const elapsed = Math.max(0, effectiveNow - scheduleStartMs - totalPausedMs);

        let acc = 0;
        for(const lvl of levels){
            const dur = Math.max(0, lvl.minutes * 60 * 1000);
            const end = acc + dur;

            if(elapsed < end){
                const remaining = Math.max(0, end - elapsed);
                const transitionAt = (stateStored === "paused") ? 0 : (effectiveNow + remaining);
                const lvlState = (lvl.type === "break") ? "break" : "running";
                const outState = (stateStored === "paused") ? "paused" : lvlState;
                return {
                    state: outState,
                    currentLevelIndex: lvl.index,
                    currentLevelType: lvl.type,
                    currentLevelLabel: lvl.label || (lvl.type==="break" ? "BREAK" : ""),
                    remainingMs: remaining,
                    transitionAtMs: transitionAt
                };
            }
            acc = end;
        }

        return { state:"finished", currentLevelIndex: levels[levels.length-1].index, currentLevelType:"level", currentLevelLabel:"", remainingMs:0, transitionAtMs:0 };
    }

    function renderTimerUiLocal(){
        if(!tournamentCache) return;
        const computed = computeScheduleAt(tournamentCache, nowMs());
        timerState.textContent = computed.state;
        currentLevelNo.textContent = String(computed.currentLevelIndex || "—");
        currentLevelLabel.textContent = String(computed.currentLevelLabel || "—");
        timerRemaining.textContent = msToClock(computed.remainingMs || 0);
        timerEndsAt.textContent = computed.transitionAtMs ? new Date(computed.transitionAtMs).toLocaleTimeString("de-DE") : "—";
    }

    async function commitComputedStateIfNeeded(){
        if(!currentTid || !tournamentCache) return;

        const tref = doc(db, "tournaments", currentTid);
        await runTransaction(db, async (tx) => {
            const snap = await tx.get(tref);
            if(!snap.exists()) return;
            const cur = snap.data() || {};
            const curTimer = cur.timer || {};
            const st = String(curTimer.state||"setup");

            // do not auto-advance when paused/setup/finished
            if(st === "paused" || st === "setup" || st === "finished") return;
            if(!curTimer.scheduleStartMs) return;

            const computed = computeScheduleAt(cur, nowMs());

            // If still running/break and current level differs OR it's finished -> write once.
            const differs =
                computed.state !== st ||
                Number(cur.currentLevelIndex||1) !== Number(computed.currentLevelIndex) ||
                String(cur.currentLevelType||"") !== String(computed.currentLevelType) ||
                String(cur.currentLevelLabel||"") !== String(computed.currentLevelLabel);

            if(!differs) return;

            tx.update(tref, {
                status: computed.state,
                currentLevelIndex: computed.currentLevelIndex,
                currentLevelType: computed.currentLevelType,
                currentLevelLabel: computed.currentLevelLabel,
                timer: {
                    ...curTimer,
                    state: computed.state
                },
                updatedAt: serverTimestamp()
            });
        });
    }

    function scheduleNextTransition(){
        clearTimerScheduler();

        // UI countdown local
        uiInterval = setInterval(renderTimerUiLocal, 250);

        if(!tournamentCache) return;
        const timer = tournamentCache.timer || {};
        const st = String(timer.state||"setup");
        if(st === "paused" || st === "setup" || st === "finished") return;

        const computed = computeScheduleAt(tournamentCache, nowMs());
        if(!computed.transitionAtMs) return;

        const delay = Math.max(0, computed.transitionAtMs - nowMs() + 75); // small buffer
        transitionTimeout = setTimeout(async () => {
            try{
                await commitComputedStateIfNeeded();
            }catch(err){
                console.warn("Transition commit failed:", err?.message);
            }
            // schedule again (in case of next level)
            scheduleNextTransition();
        }, delay);
    }

    function updateControlButtons(){
        const t = tournamentCache || {};
        const timer = t.timer || {};
        const st = String(timer.state || t.status || "setup");

        // Start button label & enable
        if(st === "paused"){
            btnStart.textContent = "Resume";
            btnStart.disabled = false;
            btnPause.disabled = true;
            btnBreak.disabled = false;
            btnNext.disabled = false;
            btnFinish.disabled = false;
            return;
        }

        if(st === "setup"){
            btnStart.textContent = "Start";
            btnStart.disabled = false;
            btnPause.disabled = true;
            btnBreak.disabled = false;
            btnNext.disabled = true;
            btnFinish.disabled = false;
            return;
        }

        if(st === "finished"){
            btnStart.textContent = "Start";
            btnStart.disabled = true;
            btnPause.disabled = true;
            btnBreak.disabled = true;
            btnNext.disabled = true;
            btnFinish.disabled = true;
            return;
        }

        // running/break
        btnStart.textContent = "Start";
        btnStart.disabled = true;
        btnPause.disabled = false;
        btnBreak.disabled = false;
        btnNext.disabled = false;
        btnFinish.disabled = false;
    }

    async function startOrResumeSchedule(){
        if(!currentTid || !tournamentCache) return;

        const tref = doc(db, "tournaments", currentTid);
        await runTransaction(db, async (tx) => {
            const snap = await tx.get(tref);
            if(!snap.exists()) return;
            const cur = snap.data() || {};
            const curTimer = cur.timer || {};
            const st = String(curTimer.state||"setup");
            const now = nowMs();

            let scheduleStartMs = Number(curTimer.scheduleStartMs||0);
            let pausedAtMs = Number(curTimer.pausedAtMs||0);
            let totalPausedMs = Number(curTimer.totalPausedMs||0);

            if(!scheduleStartMs){
                scheduleStartMs = now;
                pausedAtMs = 0;
                totalPausedMs = 0;
            }else if(st === "paused" && pausedAtMs){
                totalPausedMs = totalPausedMs + Math.max(0, now - pausedAtMs);
                pausedAtMs = 0;
            }

            const nextTimer = { ...curTimer, state:"running", scheduleStartMs, pausedAtMs, totalPausedMs };
            const computed = computeScheduleAt({ ...cur, timer: nextTimer }, now);

            tx.update(tref, {
                status: computed.state,
                currentLevelIndex: computed.currentLevelIndex,
                currentLevelType: computed.currentLevelType,
                currentLevelLabel: computed.currentLevelLabel,
                timer: { ...nextTimer, state: computed.state },
                updatedAt: serverTimestamp()
            });
        });
    }

    async function pauseSchedule(){
        if(!currentTid) return;
        const tref = doc(db, "tournaments", currentTid);
        await runTransaction(db, async (tx) => {
            const snap = await tx.get(tref);
            if(!snap.exists()) return;
            const cur = snap.data() || {};
            const curTimer = cur.timer || {};
            const st = String(curTimer.state||"setup");
            if(st === "paused" || st === "finished") return;

            const now = nowMs();
            tx.update(tref, {
                status: "paused",
                timer: { ...curTimer, state: "paused", pausedAtMs: now },
                updatedAt: serverTimestamp()
            });
        });
    }

    btnStart.addEventListener("click", async () => {
        controlsMsg.textContent = "";
        try{
            await startOrResumeSchedule();
        }catch(err){ controlsMsg.textContent = err?.message || "Start/Resume fehlgeschlagen."; }
    });

    btnPause.addEventListener("click", async () => {
        controlsMsg.textContent = "";
        try{
            await pauseSchedule();
        }catch(err){ controlsMsg.textContent = err?.message || "Pause fehlgeschlagen."; }
    });

    // Break: set current level type to break and run 10 minutes locally via schedule shift (no per-second updates)
    btnBreak.addEventListener("click", async () => {
        controlsMsg.textContent = "";
        try{
            if(!currentTid) return;
            const tref = doc(db, "tournaments", currentTid);
            const now = nowMs();

            await runTransaction(db, async (tx) => {
                const snap = await tx.get(tref);
                if(!snap.exists()) return;
                const cur = snap.data() || {};
                const curTimer = cur.timer || {};

                // Ensure schedule exists so Resume works later
                let scheduleStartMs = Number(curTimer.scheduleStartMs||0);
                if(!scheduleStartMs) scheduleStartMs = now;

                // Create a virtual "break" by pausing schedule progression for 10min using pausedAt/totalPaused trick:
                // Here we mark state break and also set pausedAtMs=0, but we shift scheduleStartMs backwards so computeScheduleAt shows break
                // Simpler: just mark state="break" and keep schedule data; next transition will compute from levels.
                // For predictable behavior: treat Break as paused schedule with separate breakUntil timestamp.
                const breakUntilMs = now + 10*60*1000;

                tx.update(tref, {
                    status: "break",
                    currentLevelType: "break",
                    currentLevelLabel: "BREAK",
                    timer: { ...curTimer, state:"break", scheduleStartMs, pausedAtMs: 0, totalPausedMs: Number(curTimer.totalPausedMs||0), breakUntilMs },
                    updatedAt: serverTimestamp()
                });
            });

            // Local scheduler will re-plan from snapshot update
        }catch(err){ controlsMsg.textContent = err?.message || "Break fehlgeschlagen."; }
    });

    // Next: shift schedule so that "now" starts next level (explicit admin action)
    btnNext.addEventListener("click", async () => {
        controlsMsg.textContent = "";
        try{
            if(!currentTid || !tournamentCache) return;
            const tref = doc(db, "tournaments", currentTid);

            await runTransaction(db, async (tx) => {
                const snap = await tx.get(tref);
                if(!snap.exists()) return;
                const cur = snap.data() || {};
                const curTimer = cur.timer || {};
                const now = nowMs();

                const levels = getLevelsOrdered();
                if(!levels.length) return;

                const curIdx = Number(cur.currentLevelIndex||1);
                const nextIdx = curIdx + 1;
                const nextLevel = levels.find(x => Number(x.index) === nextIdx) || null;
                if(!nextLevel) {
                    tx.update(tref, {
                        status: "finished",
                        timer: { ...curTimer, state:"finished" },
                        updatedAt: serverTimestamp()
                    });
                    return;
                }

                // Force schedule to start nextIdx at now by setting scheduleStartMs accordingly
                let cum = 0;
                for(const lvl of levels){
                    if(Number(lvl.index) === nextIdx) break;
                    cum += Math.max(0, lvl.minutes*60*1000);
                }

                const totalPausedMs = Number(curTimer.totalPausedMs||0);
                const scheduleStartMs = now - cum - totalPausedMs;

                const computed = computeScheduleAt(
                    { ...cur, timer: { ...curTimer, scheduleStartMs, totalPausedMs, pausedAtMs:0, state:"running" } },
                    now
                );

                tx.update(tref, {
                    status: computed.state,
                    currentLevelIndex: computed.currentLevelIndex,
                    currentLevelType: computed.currentLevelType,
                    currentLevelLabel: computed.currentLevelLabel,
                    timer: { ...curTimer, state: computed.state, scheduleStartMs, totalPausedMs, pausedAtMs: 0 },
                    updatedAt: serverTimestamp()
                });
            });

        }catch(err){ controlsMsg.textContent = err?.message || "Nächstes Level fehlgeschlagen."; }
    });

    btnFinish.addEventListener("click", async () => {
        controlsMsg.textContent = "";
        try{
            if(!confirm("Turnier wirklich auf FINISH setzen?")) return;
            const t = tournamentCache || {};
            const timer = t.timer || {};
            await updateDoc(doc(db, "tournaments", currentTid), {
                status: "finished",
                timer: { ...timer, state:"finished" },
                updatedAt: serverTimestamp()
            });
        }catch(err){ controlsMsg.textContent = err?.message || "Finish fehlgeschlagen."; }
    });

    // Break auto-end (local only): if timer.breakUntilMs exists, we resume schedule when reached without polling Firestore
    function maybeHandleBreakAutoEnd(){
        if(!currentTid || !tournamentCache) return;
        const timer = tournamentCache.timer || {};
        if(String(timer.state) !== "break") return;
        const until = Number(timer.breakUntilMs||0);
        if(!until) return;

        const delay = Math.max(0, until - nowMs() + 50);
        if(transitionTimeout) clearTimeout(transitionTimeout);
        transitionTimeout = setTimeout(async () => {
            try{
                // After break, resume schedule time without extra reads:
                // We just set state to running; computeScheduleAt will drive the correct level again.
                await updateDoc(doc(db, "tournaments", currentTid), {
                    status: "running",
                    timer: { ...timer, state:"running", breakUntilMs: null },
                    updatedAt: serverTimestamp()
                });
            }catch(err){
                console.warn("Break end update failed:", err?.message);
            }
        }, delay);
    }

    // Players add (no assignment here)
    btnAddPlayer.addEventListener("click", async () => {
        playerMsg.textContent = "";
        if(!currentTid){ playerMsg.textContent = "Kein Turnier geöffnet."; return; }
        if(!selectedUser){ playerMsg.textContent = "Bitte Spieler auswählen."; return; }

        const stack = Math.max(0, Math.round(Number(pStack.value || 0)));
        const status = pStatus.value || "playing";
        const entries = Math.max(1, Math.round(Number(pEntries.value || 1)));
        const rebuys = Math.max(0, Math.round(Number(pRebuys.value || 0)));
        const addons = Math.max(0, Math.round(Number(pAddons.value || 0)));
        const place = Math.max(0, Math.round(Number(pPlace.value || 0)));

        try{
            const pref = doc(db, "tournaments", currentTid, "players", selectedUser.uid);
            const ex = await getDoc(pref);
            if(ex.exists()){ playerMsg.textContent = "Spieler ist schon im Turnier."; return; }

            await setDoc(pref, {
                uid: selectedUser.uid,
                username: selectedUser.username,
                photoDataUrl: selectedUser.photoDataUrl || null,
                tableNo: 0,
                seat: 0,
                stack: stack || 0,
                status,
                entries: entries || 0,
                rebuys: rebuys || 0,
                addons: addons || 0,
                place: place || 0,
                createdAt: serverTimestamp(),
                updatedAt: serverTimestamp()
            }, { merge: false });

            const ps = await getDocs(collection(db, "tournaments", currentTid, "players"));
            await updateDoc(doc(db, "tournaments", currentTid), { playersCount: ps.size, updatedAt: serverTimestamp() });

            selectedUser = null;
            userDropdownLabel.textContent = "Spieler auswählen…";
            renderUsersDropdown();

            pStack.value = "";
            pEntries.value = "1";
            pRebuys.value = "0";
            pAddons.value = "0";
            pPlace.value = "";
            playerMsg.textContent = "";
        }catch(err){
            playerMsg.textContent = err?.message || "Hinzufügen fehlgeschlagen.";
        }
    });

    // ===== Gewinn-Entry: add to users/{uid}/entries + increment totals (no recompute scans) =====
    async function addTournamentEntryToUser({ userUid, dateISO, amountEUR, note }){
        const entry = {
            date: dateISO,
            type: "tournament",
            amount: Math.round(Number(amountEUR||0) * 100) / 100,
            currency: "EUR",
            note: String(note||"")
        };

        if(!entry.date || Number.isNaN(entry.amount)) throw new Error("Datum/Betrag ungültig.");

        // Add entry doc
        await addDoc(collection(db, "users", userUid, "entries"), {
            ...entry,
            createdAt: serverTimestamp(),
            updatedAt: serverTimestamp()
        });

        // Update aggregates cheaply
        await updateDoc(doc(db, "users", userUid), {
            totalEUR: increment(entry.amount),
            tournamentTotalEUR: increment(entry.amount),
            entriesCountEUR: increment(1),
            updatedAt: serverTimestamp()
        });
    }

    // Tables logic (unchanged)
    function computeActiveTablesCount(activePlayers, seats, maxTables, minPlayersForNewTable){
        let activeTables = 1;
        for(let t=2;t<=maxTables;t++){
            const threshold = (t-1) * seats + minPlayersForNewTable;
            if(activePlayers >= threshold) activeTables = t;
        }
        return Math.min(maxTables, Math.max(1, activeTables));
    }

    async function clearAllAssignments(){
        if(!currentTid) return;
        const b = writeBatch(db);
        for(const p of playersCache){
            b.update(doc(db, "tournaments", currentTid, "players", p.id), { tableNo: 0, seat: 0, updatedAt: serverTimestamp() });
        }
        await b.commit();
    }

    function computeMembershipFingerprint(players){
        const active = players
            .filter(p => (p.status||"playing") !== "out")
            .map(p => `${p.id}:${p.status||"playing"}`)
            .sort();
        return active.join("|");
    }

    async function ensureAutoAssignSalt(){
        const tab = tournamentCache?.settings?.tables || {};
        if(tab.autoAssignSalt) return String(tab.autoAssignSalt);
        const salt = Math.random().toString(36).slice(2, 10);
        await new Promise((resolve) => {
            patchTables({ autoAssignSalt: salt });
            setTimeout(resolve, 10);
        });
        return salt;
    }

    async function ensureDealersAssignments(activeTablesCount){
        if(!currentTid) return;
        const t = tournamentCache || {};
        const s = t.settings || {};
        const tab = s.tables || {};
        if(!tab.enabled || !tab.autoDealers) return;

        const admins = getAdminUids();
        if(!admins.length) return;

        const curAssign = tab.dealers || {};
        const used = new Set(Object.values(curAssign || {}).filter(Boolean));
        const nextAssign = { ...(curAssign||{}) };

        const seedBase = `${currentTid}|dealers|${tab.autoAssignSalt || "nosalt"}|${activeTablesCount}|${admins.sort().join(",")}`;
        const seed = hash32(seedBase);

        for(let i=1;i<=activeTablesCount;i++){
            const key = String(i);
            if(nextAssign[key]) continue;
            const available = admins.filter(a => !used.has(a));
            const pool = available.length ? available : admins;
            const idx = Math.floor(mulberry32(seed + i)() * pool.length);
            const chosen = pool[idx];
            if(chosen){
                nextAssign[key] = chosen;
                used.add(chosen);
            }
        }

        patchTables({ dealers: nextAssign });
    }

    async function autoAssignNow(reasonFingerprint){
        if(!currentTid) return;

        const t = tournamentCache || {};
        const tab = t.settings?.tables || {};
        if(!tab.enabled) return;

        const maxTables = Math.max(1, Number(tab.tableCount||1));
        const seats = Math.max(1, Number(tab.seatsPerTable||9));
        const minForNew = Math.max(1, Number(tab.minPlayersForNewTable||3));

        const activePlayers = playersCache.filter(p => (p.status||"playing") !== "out");
        const actCount = activePlayers.length;

        const activeTables = computeActiveTablesCount(actCount, seats, maxTables, minForNew);

        const admins = getAdminUids();
        const activeAdmins = activePlayers.filter(p => admins.includes(p.id));

        const salt = await ensureAutoAssignSalt();
        const membershipFp = reasonFingerprint ?? computeMembershipFingerprint(playersCache);

        const seed = hash32(`${currentTid}|${salt}|${membershipFp}|${activeTables}|${seats}`);

        const slots = [];
        for(let tn=1; tn<=activeTables; tn++){
            for(let s=1; s<=seats; s++){
                slots.push({ tableNo: tn, seat: s });
            }
        }

        const assigns = new Map();

        // Admin rule:
        // - If exactly 1 admin active -> no special rule
        // - If >=2 admins active -> try 1 admin per active table if possible
        const adminCount = activeAdmins.length;

        if(adminCount >= 2){
            const adminPick = seededShuffle(activeAdmins, seed ^ 0xA53C91);
            const tablesNeedingAdmin = [];
            for(let tn=1; tn<=activeTables; tn++) tablesNeedingAdmin.push(tn);

            const assignCount = Math.min(tablesNeedingAdmin.length, adminPick.length);

            for(let i=0;i<assignCount;i++){
                const tn = tablesNeedingAdmin[i];

                const tableSlotIdx = [];
                for(let k=0;k<slots.length;k++){
                    if(slots[k].tableNo === tn) tableSlotIdx.push(k);
                }
                if(!tableSlotIdx.length) continue;

                const rnd = mulberry32((seed ^ 0xBEEFCC) + tn)();
                const pickIdxInList = Math.floor(rnd * tableSlotIdx.length);
                const slotIdx = tableSlotIdx[pickIdxInList];

                const chosenAdmin = adminPick[i];
                if(chosenAdmin){
                    const slot = slots.splice(slotIdx,1)[0];
                    assigns.set(chosenAdmin.id, slot);
                }
            }
        }

        const remaining = activePlayers.filter(p => !assigns.has(p.id));
        const remainingShuffled = seededShuffle(remaining, seed ^ 0x3F12AB);

        for(const p of remainingShuffled){
            if(!slots.length) break;
            assigns.set(p.id, slots.shift());
        }

        const b = writeBatch(db);
        for(const p of playersCache){
            if((p.status||"playing")==="out"){
                b.update(doc(db, "tournaments", currentTid, "players", p.id), { tableNo: 0, seat: 0, updatedAt: serverTimestamp() });
                continue;
            }
            const a = assigns.get(p.id);
            if(!a){
                b.update(doc(db, "tournaments", currentTid, "players", p.id), { tableNo: 0, seat: 0, updatedAt: serverTimestamp() });
            }else{
                b.update(doc(db, "tournaments", currentTid, "players", p.id), { tableNo: a.tableNo, seat: a.seat, updatedAt: serverTimestamp() });
            }
        }
        await b.commit();

        patchTables({ lastAssignedFingerprint: membershipFp });

        if(tab.autoDealers){
            await ensureDealersAssignments(activeTables);
        }
    }

    async function maybeAutoAssignTables(){
        const tab = tournamentCache?.settings?.tables || {};
        if(!tab.enabled) return;
        if(tab.autoAssign !== true) return;

        const fp = computeMembershipFingerprint(playersCache);
        const stored = String(tab.lastAssignedFingerprint || "");
        if(stored && stored === fp){
            lastAutoAssignFingerprintSeen = fp;
            return;
        }

        if(lastPlayersMembershipFingerprint === fp && lastAutoAssignFingerprintSeen === fp) return;

        lastPlayersMembershipFingerprint = fp;
        lastAutoAssignFingerprintSeen = fp;
        await autoAssignNow(fp);
    }

    btnAutoAssignNow.addEventListener("click", async () => {
        tablesMsg.textContent = "";
        try{
            const fp = computeMembershipFingerprint(playersCache);
            await autoAssignNow(fp);
        }
        catch(err){ tablesMsg.textContent = err?.message || "Auto-Zuweisung fehlgeschlagen."; }
    });

    btnClearAssignments.addEventListener("click", async () => {
        tablesMsg.textContent = "";
        try{
            if(!confirm("Zuweisung (Table/Seat) für alle Spieler löschen?")) return;
            await clearAllAssignments();
            patchTables({ lastAssignedFingerprint: null });
            lastAutoAssignFingerprintSeen = null;
        }catch(err){ tablesMsg.textContent = err?.message || "Löschen fehlgeschlagen."; }
    });

    btnManualAssign.addEventListener("click", async () => {
        manualMsg.textContent = "";
        if(!currentTid) return;
        const pid = manualPlayerPick.value || "";
        const tn = Math.max(0, Math.round(Number(manualTableNo.value||0)));
        const sn = Math.max(0, Math.round(Number(manualSeatNo.value||0)));
        if(!pid){ manualMsg.textContent = "Bitte Spieler auswählen."; return; }

        const tab = tournamentCache?.settings?.tables || {};
        if(!tab.enabled){ manualMsg.textContent = "Tables sind deaktiviert."; return; }

        const maxTables = Math.max(1, Number(tab.tableCount||1));
        const seats = Math.max(1, Number(tab.seatsPerTable||9));

        if(tn < 1 || tn > maxTables){ manualMsg.textContent = `Table muss zwischen 1 und ${maxTables} liegen.`; return; }
        if(sn < 1 || sn > seats){ manualMsg.textContent = `Seat muss zwischen 1 und ${seats} liegen.`; return; }

        if(tab.enforceSeats){
            const occupied = playersCache.find(p => (p.status||"playing")!=="out" && Number(p.tableNo||0)===tn && Number(p.seat||0)===sn && p.id !== pid);
            if(occupied){ manualMsg.textContent = "Seat ist bereits belegt."; return; }
        }

        try{
            await updateDoc(doc(db, "tournaments", currentTid, "players", pid), { tableNo: tn, seat: sn, updatedAt: serverTimestamp() });
            const fp = computeMembershipFingerprint(playersCache);
            patchTables({ lastAssignedFingerprint: fp });
            lastAutoAssignFingerprintSeen = fp;
        }catch(err){
            manualMsg.textContent = err?.message || "Manuelle Zuweisung fehlgeschlagen.";
        }
    });

    function renderPlayersTable(){
        const tab = tournamentCache?.settings?.tables || {};
        const tablesOn = !!tab.enabled;

        tbodyPlayers.innerHTML = playersCache.map(p => {
            const photo = p.photoDataUrl || defaultAvatarDataUrl();
            const tableVal = Number(p.tableNo||0);
            const seatVal = Number(p.seat||0);

            const tableCell = tablesOn
                ? `<span class="badge badge-soft">${tableVal>0?escapeHtml(String(tableVal)):"—"}</span>`
                : `<span class="badge badge-soft readonly-gray">—</span>`;

            const seatCell = tablesOn
                ? `<span class="badge badge-soft">${seatVal>0?escapeHtml(String(seatVal)):"—"}</span>`
                : `<span class="badge badge-soft readonly-gray">—</span>`;

            const adminTag = isAdminUid(p.id) ? `<span class="badge badge-soft ms-1">ADMIN</span>` : "";

            const defaultNote = `${tournamentCache?.name || "Turnier"} (${currentTid})`;
            const defaultDate = todayISO();

            return `
        <tr>
          <td>
            <div class="d-flex align-items-center">
              <img src="${escapeHtml(photo)}" class="avatar" alt="">
              <div class="ms-2">
                <div class="fw-semibold">${escapeHtml(p.username || "(ohne username)")} ${adminTag}</div>
              </div>
            </div>
          </td>

          <td class="text-end">${tableCell}</td>
          <td class="text-end">${seatCell}</td>


          <td>
            <select class="form-select form-select-sm" data-edit-status="${escapeHtml(p.id)}" style="width:140px;">
              <option value="playing" ${p.status==="playing"?"selected":""}>playing</option>
              <option value="out" ${p.status==="out"?"selected":""}>out</option>
            </select>
          </td>

          <td class="text-end">
            <input class="form-control form-control-sm" style="width:120px; margin-left:auto;"
              type="number" step="1" value="${escapeHtml(String(p.stack ?? 0))}" data-edit-stack="${escapeHtml(p.id)}">
          </td>

          <td class="text-end">
            <input class="form-control form-control-sm" style="width:90px; margin-left:auto;"
              type="number" step="1" value="${escapeHtml(String(p.rebuys ?? 0))}" data-edit-rebuys="${escapeHtml(p.id)}">
          </td>

          <td class="text-end">
            <input class="form-control form-control-sm" style="width:90px; margin-left:auto;"
              type="number" step="1" value="${escapeHtml(String(p.addons ?? 0))}" data-edit-addons="${escapeHtml(p.id)}">
          </td>

          <td class="text-end">
            <input class="form-control form-control-sm" style="width:90px; margin-left:auto;"
              type="number" step="1" value="${escapeHtml(String(p.place ?? 0))}" data-edit-place="${escapeHtml(p.id)}">
          </td>



          <td class="text-end">
            <button class="btn btn-sm btn-outline-danger" data-remove-player="${escapeHtml(p.id)}" type="button">Entfernen</button>
          </td>
        </tr>
      `;
        }).join("") || `<tr><td colspan="11" class="small-muted">Noch keine Spieler im Turnier.</td></tr>`;

        manualPlayerPick.innerHTML = [`<option value="">Spieler auswählen…</option>`].concat(
            playersCache
                .filter(p => (p.status||"playing")!=="out")
                .slice()
                .sort((a,b)=> String(a.username||"").localeCompare(String(b.username||""),"de"))
                .map(p => `<option value="${escapeHtml(p.id)}">${escapeHtml(p.username||p.id)}</option>`)
        ).join("");
    }

    function renderTablesUi(){
        const tab = tournamentCache?.settings?.tables || {};
        const enabled = !!tab.enabled;
        const maxTables = Math.max(1, Number(tab.tableCount||1));
        const seats = Math.max(1, Number(tab.seatsPerTable||9));
        const minForNew = Math.max(1, Number(tab.minPlayersForNewTable||3));

        const admins = getAdminUids();
        const activePlayers = playersCache.filter(p => (p.status||"playing")!=="out");

        adminsCount.textContent = String(admins.length);
        activePlayersCount.textContent = String(activePlayers.length);

        if(!enabled){
            tablesHint.textContent = "Tables sind deaktiviert. Aktivieren, um Belegung zu sehen/zu ändern.";
        }else{
            const activeTables = computeActiveTablesCount(activePlayers.length, seats, maxTables, minForNew);
            tablesHint.textContent = `Aktiv: ${activeTables}/${maxTables} Tables • Seats/Table: ${seats} • Min für neuen Table: ${minForNew}`;
        }

        const byTable = new Map();
        for(let i=1;i<=maxTables;i++) byTable.set(i, []);
        for(const p of activePlayers){
            const tn = Number(p.tableNo||0);
            if(tn>0 && byTable.has(tn)) byTable.get(tn).push(p);
        }
        for(const [tn, arr] of byTable.entries()){
            arr.sort((a,b)=> Number(a.seat||0) - Number(b.seat||0));
        }

        tablesGrid.innerHTML = Array.from({length: maxTables}, (_,i)=> i+1).map(tn => {
            const list = byTable.get(tn) || [];
            const seatMap = new Map();
            for(const p of list){
                const sn = Number(p.seat||0);
                if(sn>0) seatMap.set(sn, p);
            }

            const seatsHtml = Array.from({length: seats}, (_,j)=> j+1).map(sn => {
                const p = seatMap.get(sn) || null;
                const filled = !!p;
                const admin = p ? isAdminUid(p.id) : false;
                const cls = [
                    "table-seat",
                    enabled ? "" : "disabled",
                    filled ? "filled" : "empty",
                    admin ? "admin" : ""
                ].join(" ").trim();

                const title = !enabled
                    ? "Tables deaktiviert"
                    : filled
                        ? `${p.username || p.id} (Seat ${sn})${admin ? " • ADMIN" : ""}`
                        : `Seat ${sn}`;

                return `<div class="${cls}" title="${escapeHtml(title)}"><span>${escapeHtml(String(sn))}</span></div>`;
            }).join("");

            const count = list.length;
            const hasAdmin = list.some(p => isAdminUid(p.id));

            return `
        <div class="col-12">
          <div class="table-card">
            <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
              <div class="fw-semibold text-white">Table ${tn}</div>
              <div class="d-flex gap-2 align-items-center flex-wrap">
                <span class="badge badge-soft">${enabled ? `${count}/${seats}` : "deaktiviert"}</span>
                <span class="badge badge-soft">${enabled ? (hasAdmin ? "Admin: ja" : "Admin: nein") : "Admin: —"}</span>
              </div>
            </div>
            <div class="mt-2 seats-grid">${seatsHtml}</div>
          </div>
        </div>
      `;
        }).join("");
    }

    // Payout percents
    function renderPayoutPercentsFromSettings(){
        const s = tournamentCache?.settings || {};
        const cur = Array.isArray(s.payoutPercents) ? s.payoutPercents : [];
        const rows = cur.slice().sort((a,b)=> Number(a.place||0) - Number(b.place||0));

        payoutsCount.textContent = String(rows.length);

        tbodyPayouts.innerHTML = rows.map(r => {
            const place = Number(r.place||0);
            const percent = Number(r.percent||0);
            return `
        <tr>
          <td class="text-end">${escapeHtml(String(place))}</td>
          <td class="text-end">
            <input class="form-control form-control-sm" style="width:120px; margin-left:auto;"
              type="number" step="0.01" value="${escapeHtml(String(percent))}" data-edit-payout-percent="${escapeHtml(String(place))}">
          </td>
          <td class="text-end">
            <button class="btn btn-sm btn-outline-danger" data-remove-payout-percent="${escapeHtml(String(place))}" type="button">Löschen</button>
          </td>
        </tr>
      `;
        }).join("") || `<tr><td colspan="3" class="small-muted">Noch keine Payouts.</td></tr>`;
    }

    btnAddPayoutPercent.addEventListener("click", async () => {
        payoutMsg.textContent = "";
        if(!currentTid) return;

        const place = Math.max(1, Math.round(Number(payoutPlace.value||1)));
        const percent = Math.max(0, Math.round(Number(payoutPercent.value||0)*100)/100);

        try{
            const s = tournamentCache?.settings || {};
            const cur = Array.isArray(s.payoutPercents) ? s.payoutPercents : [];
            const next = cur.filter(x => Number(x.place||0) !== place).concat([{ place, percent }]);
            await scheduleSettingsPatch({ payoutPercents: next });
            payoutPlace.value = String(place + 1);
            payoutPercent.value = "0";
        }catch(err){
            payoutMsg.textContent = err?.message || "Hinzufügen fehlgeschlagen.";
        }
    });

    // Structure generator rounding
    function roundToStep(v, step){
        const s = Math.max(1, Number(step||50));
        return Math.max(0, Math.round(Number(v||0)/s) * s);
    }
    async function generateStructure(){
        if(!currentTid) return;
        structureMsg.textContent = "";

        const levelMin = Math.max(1, Math.round(Number(genLevelMinutes.value||15)));
        const startSb = Math.max(1, Math.round(Number(genStartSb.value||100)));
        const startAnte = Math.max(0, Math.round(Number(genStartAnte.value||0)));
        const levelsCount = Math.max(1, Math.round(Number(genLevelsCount.value||16)));
        const growth = Math.max(1.01, Number(genGrowth.value||1.30));
        const breakEvery = Math.max(0, Math.round(Number(genBreakEvery.value||0)));
        const breakMin = Math.max(1, Math.round(Number(genBreakMinutes.value||10)));
        const step = Math.max(1, Math.round(Number(genRoundStep.value||50)));
        const bbFactor = Math.max(2, Math.round(Number(genBbFactor.value||2)));

        await deleteSubcollectionDocs(currentTid, "levels");

        let sb = startSb;
        let ante = startAnte;

        const b = writeBatch(db);
        let idx = 1;

        const addLevelDoc = (index, type, minutes, sbv, bbv, antev, label) => {
            const id = String(index);
            b.set(doc(db, "tournaments", currentTid, "levels", id), {
                index, type, minutes, sb: sbv, bb: bbv, ante: antev, label,
                updatedAt: serverTimestamp(), createdAt: serverTimestamp()
            }, { merge: false });
        };

        for(let l=1; l<=levelsCount; l++){
            const sbR = roundToStep(sb, step);
            const bbR = roundToStep(sbR * bbFactor, step);
            const anteR = roundToStep(ante, step);

            addLevelDoc(idx, "level", levelMin, sbR, bbR, anteR, `${sbR}/${bbR}${anteR>0?` (${anteR})`:""}`);
            idx++;

            sb = sbR * growth;
            if(anteR > 0) ante = anteR * growth;

            if(breakEvery > 0 && l < levelsCount && (l % breakEvery === 0)){
                addLevelDoc(idx, "break", breakMin, 0, 0, 0, "BREAK");
                idx++;
            }
        }

        await b.commit();

        await updateDoc(doc(db, "tournaments", currentTid), {
            currentLevelIndex: 1,
            currentLevelType: "level",
            currentLevelLabel: "",
            updatedAt: serverTimestamp()
        });
    }

    btnGenerateStructure.addEventListener("click", async () => {
        structureMsg.textContent = "";
        try{
            if(!confirm("Struktur wirklich erzeugen? (überschreibt alle Levels)")) return;
            await generateStructure();
        }catch(err){
            structureMsg.textContent = err?.message || "Erzeugen fehlgeschlagen.";
        }
    });

    // Player + Level edits
    document.addEventListener("change", async (e) => {
        if(!currentTid) return;

        try{
            const stackEl = e.target.closest("input[data-edit-stack]");
            const entriesEl = e.target.closest("input[data-edit-entries]");
            const rebuysEl = e.target.closest("input[data-edit-rebuys]");
            const addonsEl = e.target.closest("input[data-edit-addons]");
            const placeEl = e.target.closest("input[data-edit-place]");
            const statusEl = e.target.closest("select[data-edit-status]");

            if(stackEl){
                const pid = stackEl.getAttribute("data-edit-stack");
                const stack = Math.max(0, Math.round(Number(stackEl.value||0)));
                await updateDoc(doc(db, "tournaments", currentTid, "players", pid), { stack, updatedAt: serverTimestamp() });
            }
            if(entriesEl){
                const pid = entriesEl.getAttribute("data-edit-entries");
                const entries = Math.max(1, Math.round(Number(entriesEl.value||0)));
                await updateDoc(doc(db, "tournaments", currentTid, "players", pid), { entries, updatedAt: serverTimestamp() });
            }
            if(rebuysEl){
                const pid = rebuysEl.getAttribute("data-edit-rebuys");
                const rebuys = Math.max(0, Math.round(Number(rebuysEl.value||0)));
                await updateDoc(doc(db, "tournaments", currentTid, "players", pid), { rebuys, updatedAt: serverTimestamp() });
            }
            if(addonsEl){
                const pid = addonsEl.getAttribute("data-edit-addons");
                const addons = Math.max(0, Math.round(Number(addonsEl.value||0)));
                await updateDoc(doc(db, "tournaments", currentTid, "players", pid), { addons, updatedAt: serverTimestamp() });
            }
            if(placeEl){
                const pid = placeEl.getAttribute("data-edit-place");
                const place = Math.max(0, Math.round(Number(placeEl.value||0)));
                await updateDoc(doc(db, "tournaments", currentTid, "players", pid), { place, updatedAt: serverTimestamp() });
            }
            if(statusEl){
                const pid = statusEl.getAttribute("data-edit-status");
                const nextStatus = statusEl.value;

                const patch = { status: nextStatus, updatedAt: serverTimestamp() };
                if(nextStatus === "out"){
                    patch.outAt = serverTimestamp(); // wichtig!
                }else{
                    patch.outAt = null;
                    patch.place = 0; // wieder „drin“
                }

                await updateDoc(doc(db, "tournaments", currentTid, "players", pid), patch);

                patchTables({ lastAssignedFingerprint: null });
                lastAutoAssignFingerprintSeen = null;
            }


            // levels
            const typeEl = e.target.closest("select[data-edit-level-type]");
            const minEl = e.target.closest("input[data-edit-level-min]");
            const sbEl = e.target.closest("input[data-edit-level-sb]");
            const bbEl = e.target.closest("input[data-edit-level-bb]");
            const anteEl = e.target.closest("input[data-edit-level-ante]");
            const labelEl = e.target.closest("input[data-edit-level-label]");

            if(typeEl){
                const lid = typeEl.getAttribute("data-edit-level-type");
                await updateDoc(doc(db, "tournaments", currentTid, "levels", lid), { type: typeEl.value, updatedAt: serverTimestamp() });
            }
            if(minEl){
                const lid = minEl.getAttribute("data-edit-level-min");
                await updateDoc(doc(db, "tournaments", currentTid, "levels", lid), { minutes: Math.max(0, Math.round(Number(minEl.value||0))), updatedAt: serverTimestamp() });
            }
            if(sbEl){
                const lid = sbEl.getAttribute("data-edit-level-sb");
                await updateDoc(doc(db, "tournaments", currentTid, "levels", lid), { sb: Math.max(0, Math.round(Number(sbEl.value||0))), updatedAt: serverTimestamp() });
            }
            if(bbEl){
                const lid = bbEl.getAttribute("data-edit-level-bb");
                await updateDoc(doc(db, "tournaments", currentTid, "levels", lid), { bb: Math.max(0, Math.round(Number(bbEl.value||0))), updatedAt: serverTimestamp() });
            }
            if(anteEl){
                const lid = anteEl.getAttribute("data-edit-level-ante");
                await updateDoc(doc(db, "tournaments", currentTid, "levels", lid), { ante: Math.max(0, Math.round(Number(anteEl.value||0))), updatedAt: serverTimestamp() });
            }
            if(labelEl){
                const lid = labelEl.getAttribute("data-edit-level-label");
                await updateDoc(doc(db, "tournaments", currentTid, "levels", lid), { label: String(labelEl.value||""), updatedAt: serverTimestamp() });
            }

            // payouts percent edit
            const payoutEdit = e.target.closest("input[data-edit-payout-percent]");
            if(payoutEdit){
                const place = Number(payoutEdit.getAttribute("data-edit-payout-percent")||0);
                const percent = Math.max(0, Math.round(Number(payoutEdit.value||0)*100)/100);
                const s = tournamentCache?.settings || {};
                const cur = Array.isArray(s.payoutPercents) ? s.payoutPercents : [];
                const next = cur.filter(x => Number(x.place||0) !== place).concat([{ place, percent }]);
                await scheduleSettingsPatch({ payoutPercents: next });
            }

        }catch(err){
            playersTableMsg.textContent = err?.message || "Update fehlgeschlagen.";
        }
    });

    document.addEventListener("click", async (e) => {
        if(!currentTid) return;

        const rmP = e.target.closest("button[data-remove-player]");
        if(rmP){
            const pid = rmP.getAttribute("data-remove-player");
            if(pid && confirm("Spieler entfernen?")){
                try{
                    await deleteDoc(doc(db, "tournaments", currentTid, "players", pid));
                    const ps = await getDocs(collection(db, "tournaments", currentTid, "players"));
                    await updateDoc(doc(db, "tournaments", currentTid), { playersCount: ps.size, updatedAt: serverTimestamp() });

                    renderUsersDropdown();
                    patchTables({ lastAssignedFingerprint: null });
                    lastAutoAssignFingerprintSeen = null;
                }catch(err){
                    playersTableMsg.textContent = err?.message || "Entfernen fehlgeschlagen.";
                }
            }
        }

        const winBtn = e.target.closest("button[data-win-add]");
        if(winBtn){
            const pid = winBtn.getAttribute("data-win-add");
            try{
                const dateEl = document.querySelector(`input[data-win-date="${CSS.escape(pid)}"]`);
                const amtEl = document.querySelector(`input[data-win-amount="${CSS.escape(pid)}"]`);
                const noteEl = document.querySelector(`input[data-win-note="${CSS.escape(pid)}"]`);
                const dateISO = (dateEl?.value || "").trim() || todayISO();
                const amountEUR = Math.round(Number(amtEl?.value || 0) * 100) / 100;
                const note = (noteEl?.value || "").trim();

                if(Number.isNaN(amountEUR)){ throw new Error("Betrag ungültig."); }
                if(!confirm(`Entry speichern für Spieler?\n${amountEUR.toFixed(2)} EUR`)) return;

                winBtn.disabled = true;
                await addTournamentEntryToUser({ userUid: pid, dateISO, amountEUR, note });
                if(amtEl) amtEl.value = "";
                playersTableMsg.textContent = "";
            }catch(err){
                playersTableMsg.textContent = err?.message || "Entry Speichern fehlgeschlagen.";
            }finally{
                winBtn.disabled = false;
            }
        }

        const rmL = e.target.closest("button[data-remove-level]");
        if(rmL){
            const lid = rmL.getAttribute("data-remove-level");
            if(lid && confirm("Level löschen?")){
                try{ await deleteDoc(doc(db, "tournaments", currentTid, "levels", lid)); }
                catch(err){ levelsMsg.textContent = err?.message || "Löschen fehlgeschlagen."; }
            }
        }

        const rmPay = e.target.closest("button[data-remove-payout-percent]");
        if(rmPay){
            const place = Number(rmPay.getAttribute("data-remove-payout-percent") || 0);
            if(place > 0 && confirm("Payout-Prozent löschen?")){
                try{
                    const s = tournamentCache?.settings || {};
                    const cur = Array.isArray(s.payoutPercents) ? s.payoutPercents : [];
                    const next = cur.filter(x => Number(x.place||0) !== place);
                    await scheduleSettingsPatch({ payoutPercents: next });
                }catch(err){
                    payoutsTableMsg.textContent = err?.message || "Löschen fehlgeschlagen.";
                }
            }
        }
    });

    function renderLevelsTable(){
        tbodyLevels.innerHTML = levelsCache.map(l => {
            const typ = String(l.type || "level");
            return `
        <tr>
          <td>${escapeHtml(String(l.index ?? ""))}</td>

          <td>
            <select class="form-select form-select-sm" data-edit-level-type="${escapeHtml(l.id)}" style="width:130px;">
              <option value="level" ${typ==="level"?"selected":""}>level</option>
              <option value="break" ${typ==="break"?"selected":""}>break</option>
            </select>
          </td>

          <td class="text-end">
            <input class="form-control form-control-sm" style="width:90px; margin-left:auto;"
              type="number" step="1" value="${escapeHtml(String(l.minutes ?? 0))}" data-edit-level-min="${escapeHtml(l.id)}">
          </td>

          <td class="text-end">
            <input class="form-control form-control-sm" style="width:110px; margin-left:auto;"
              type="number" step="1" value="${escapeHtml(String(l.sb ?? 0))}" data-edit-level-sb="${escapeHtml(l.id)}">
          </td>

          <td class="text-end">
            <input class="form-control form-control-sm" style="width:110px; margin-left:auto;"
              type="number" step="1" value="${escapeHtml(String(l.bb ?? 0))}" data-edit-level-bb="${escapeHtml(l.id)}">
          </td>

          <td class="text-end">
            <input class="form-control form-control-sm" style="width:110px; margin-left:auto;"
              type="number" step="1" value="${escapeHtml(String(l.ante ?? 0))}" data-edit-level-ante="${escapeHtml(l.id)}">
          </td>

          <td>
            <input class="form-control form-control-sm" style="min-width:220px;"
              value="${escapeHtml(String(l.label ?? ""))}" data-edit-level-label="${escapeHtml(l.id)}">
          </td>

          <td class="text-end">
            <button class="btn btn-sm btn-outline-danger" data-remove-level="${escapeHtml(l.id)}" type="button">Löschen</button>
          </td>
        </tr>
      `;
        }).join("") || `<tr><td colspan="8" class="small-muted">Noch keine Levels.</td></tr>`;
    }

    // Danger helpers
    async function deleteSubcollectionDocs(tid, sub){
        const snap = await getDocs(collection(db, "tournaments", tid, sub));
        if(snap.empty) return;
        const b = writeBatch(db);
        snap.docs.forEach(d => b.delete(d.ref));
        await b.commit();
    }

    btnResetTournament.addEventListener("click", async () => {
        dangerMsg.textContent = "";
        if(!currentTid){ dangerMsg.textContent = "Kein Turnier geöffnet."; return; }
        if(!confirm("Reset wirklich ausführen? (löscht players/levels/events + setzt Timer/Status zurück)")) return;

        try{
            clearTimerScheduler();

            await deleteSubcollectionDocs(currentTid, "players");
            await deleteSubcollectionDocs(currentTid, "levels");
            await deleteSubcollectionDocs(currentTid, "events");

            const tref = doc(db, "tournaments", currentTid);
            const snap = await getDoc(tref);
            if(!snap.exists()){ dangerMsg.textContent = "Turnier existiert nicht mehr."; return; }

            const cur = snap.data() || {};
            const timer = cur.timer || {};

            await updateDoc(tref, {
                status: "setup",
                playersCount: 0,

                currentLevelIndex: 1,
                currentLevelType: "level",
                currentLevelLabel: "",

                timer: {
                    ...timer,
                    state: "setup",
                    scheduleStartMs: 0,
                    pausedAtMs: 0,
                    totalPausedMs: 0,
                    breakUntilMs: null
                },

                settings: {
                    ...(cur.settings || {}),
                    tables: {
                        ...((cur.settings || {}).tables || {}),
                        dealers: {},
                        lastAssignedFingerprint: null
                    }
                },

                updatedAt: serverTimestamp()
            });

            // re-open to refresh caches (listeners will rebuild UI anyway)
            await openTournament(currentTid);

            dangerMsg.textContent = "";
        }catch(err){
            dangerMsg.textContent = err?.message || "Reset fehlgeschlagen.";
        }
    });

    btnDeleteTournament.addEventListener("click", async () => {
        dangerMsg.textContent = "";
        if(!currentTid){ dangerMsg.textContent = "Kein Turnier geöffnet."; return; }
        if(!confirm("Turnier wirklich LÖSCHEN? (inkl. Subcollections)")) return;

        try{
            clearTimerScheduler();

            await deleteSubcollectionDocs(currentTid, "players");
            await deleteSubcollectionDocs(currentTid, "levels");
            await deleteSubcollectionDocs(currentTid, "events");
            await deleteDoc(doc(db, "tournaments", currentTid));

            await openTournament(null);
            dangerMsg.textContent = "";
        }catch(err){
            dangerMsg.textContent = err?.message || "Löschen fehlgeschlagen.";
        }
    });

    // ===== Open tournament + listeners =====
    async function openTournament(tid){
        stopTournamentListeners();
        currentTid = tid || null;

        tidBadge.textContent = currentTid || "—";
        setDisplayLink(currentTid || "");

        if(!currentTid){
            statusBadge.textContent = "Status: —";
            enableTournamentWrite(false);
            return;
        }

        enableTournamentWrite(true);

        const tref = doc(db, "tournaments", currentTid);

        // Tournament doc listener
        unsubTournament = onSnapshot(
            tref,
            (snap) => {
                if(!snap.exists()){
                    tournamentsMsg.textContent = "Turnier existiert nicht mehr.";
                    openTournament(null);
                    return;
                }

                tournamentCache = snap.data() || {};

                renderPayoutTab();


                const st = String(tournamentCache.timer?.state || tournamentCache.status || "setup");
                statusBadge.innerHTML = `Status: <span class="badge badge-soft">${escapeHtml(st)}</span>`;

                // display link again (safe)
                setDisplayLink(currentTid);

                // Fill controls fields
                tName.value = tournamentCache.name || "";
                tLocation.value = tournamentCache.location || "";
                tType.value = tournamentCache.type || "rebuy_addon";
                tBuyIn.value = String(tournamentCache.buyInEUR ?? 0);
                tStartStack.value = String(tournamentCache.startStack ?? 0);
                tMaxPlayers.value = String(tournamentCache.maxPlayers ?? 50);

                // Settings
                const s = tournamentCache.settings || {};
                rebuyEnabled.value = String(!!s.rebuyEnabled);
                addonEnabled.value = String(!!s.addonEnabled);
                rebuyEUR.value = String(s.rebuyEUR ?? (tournamentCache.buyInEUR ?? 0));
                addonEUR.value = String(s.addonEUR ?? (tournamentCache.buyInEUR ?? 0));
                rebuyUntilLevel.value = String(s.rebuyUntilLevel ?? 8);
                addonUntilLevel.value = String(s.addonUntilLevel ?? 8);
                rebuyMaxPerPlayer.value = (s.rebuyMaxPerPlayer === null || s.rebuyMaxPerPlayer === undefined) ? "" : String(s.rebuyMaxPerPlayer);
                addonMaxPerPlayer.value = (s.addonMaxPerPlayer === null || s.addonMaxPerPlayer === undefined) ? "" : String(s.addonMaxPerPlayer);
                displayTheme.value = String(s.displayTheme || "default");
                showWinnersOverlay.value = String(!!s.showWinnersOverlay);

                // Tables settings
                const tab = s.tables || {};
                tablesEnabled.value = String(!!tab.enabled);
                tableCount.value = String(tab.tableCount ?? 1);
                seatsPerTable.value = String(tab.seatsPerTable ?? 9);
                enforceSeats.value = String(tab.enforceSeats !== false);
                autoAssignTables.value = String(tab.autoAssign !== false);
                autoDealers.value = String(tab.autoDealers !== false);
                minPlayersPerTableForAdmin.value = String(tab.minPlayersForNewTable ?? 3);

                // Payouts
                renderPayoutPercentsFromSettings();

                // Controls
                updateControlButtons();

                // Timer UI + local schedule planning (no polling writes)
                renderTimerUiLocal();
                scheduleNextTransition();
                maybeHandleBreakAutoEnd();

                // Tables UI (needs caches, but render a baseline)
                renderTablesUi();


            },
            (err) => {
                tournamentsMsg.textContent = err?.message || "Fehler beim Laden des Turniers.";
            }
        );

        // Players listener
        unsubPlayers = onSnapshot(
            query(collection(db, "tournaments", currentTid, "players"), orderBy("username", "asc")),
            async (snap) => {
                playersCache = snap.docs.map(d => ({ id: d.id, ...(d.data()||{}) }));
                playersCount.textContent = String(playersCache.length);

                // Update users dropdown so "already in tournament" are removed
                renderUsersDropdown();

                // Players table + manual picker
                renderPlayersTable();

                // Tables visual
                renderTablesUi();

                renderPayoutTab();

                renderPayoutTab();



                // Auto-assign only when membership changes / needed
                try{
                    await maybeAutoAssignTables();
                }catch(err){
                    // silent to prevent loops; errors shown via tablesMsg on manual actions
                }
            },
            (err) => { playersTableMsg.textContent = err?.message || "Fehler beim Laden der Spieler."; }
        );

        // Levels listener
        unsubLevels = onSnapshot(
            query(collection(db, "tournaments", currentTid, "levels"), orderBy("index", "asc")),
            (snap) => {
                levelsCache = snap.docs.map(d => ({ id: d.id, ...(d.data()||{}) }));

                renderLevelsTable();

                // Levels change affects local schedule -> re-plan
                renderTimerUiLocal();
                scheduleNextTransition();
            },
            (err) => { levelsMsg.textContent = err?.message || "Fehler beim Laden der Levels."; }
        );
    }

    function renderPayoutTab(){
        payoutMsg.textContent = "";

        const isFinished = String(tournamentCache?.status || tournamentCache?.timer?.state || "") === "finished";
        tabPayoutBtn.classList.toggle("d-none", !isFinished);

        // Wenn nicht finished: Tab-Inhalt nicht rendern
        if(!isFinished){
            tbodyPayout.innerHTML = "";
            return;
        }

        const rows = (playersCache || []).map(p => {
            const settledAt = p?.settledAt || null; // siehe Abschnitt 6 (Markierung)
            const status = settledAt ? "Gebucht" : "Offen";

            const cost = getPlayerCostsEUR(p);
            const gross = getGrossWinEURForPlace(Number(p?.place || 0));
            const net = gross - cost;

            return `
      <tr>
        <td>${escapeHtml(p?.username || p?.displayName || p?.name || "—")}</td>

        <td class="text-end ${amountClass(net)}">${formatEUR(net)}</td>
        <td class="small-muted">${escapeHtml(status)}</td>
      </tr>
    `;
        }).join("");

        tbodyPayout.innerHTML = rows || `<tr><td colspan="3" class="small-muted">Keine Spieler.</td></tr>`;
    }


    // ===== Init =====
    enableTournamentWrite(false);
    startTournamentsListener();
    startUsersListener();
    startAdminsListener();

    onAuthStateChanged(auth, async (user) => {
        currentUser = user || null;

        if(!user){
            setUI(false);
            whoAmI.textContent = "";
            stopTournamentListeners();
            currentTid = null;
            tidBadge.textContent = "—";
            setDisplayLink("");
            enableTournamentWrite(false);
            return;
        }

        const ok = await isAdminUid2(user.uid);
        if(!ok){
            setUI(false);
            loginMsg.textContent = "Kein Admin-Zugriff für diesen Account.";
            await signOut(auth);
            document.getElementById("btnBackToApp").classList.add("d-none");
            return;
        }

        setUI(true);
        whoAmI.textContent = `UID: ${user.uid}`;

        // Keep global lists live
        startTournamentsListener();
        startUsersListener();
        startAdminsListener();

        // No tournament selected by default
        await openTournament(null);

        document.getElementById("btnBackToApp").classList.remove("d-none");
    });

    async function isAdminUid2(uid){
        const ref = doc(db, "admins", uid);
        const snap = await getDoc(ref);
        return snap.exists();
    }

    btnBookPayouts.addEventListener("click", async () => {
        payoutMsg.textContent = "";
        if(!currentTid){ payoutMsg.textContent = "Kein Turnier geöffnet."; return; }

        const isFinished = String(tournamentCache?.status || tournamentCache?.timer?.state || "") === "finished";
        if(!isFinished){ payoutMsg.textContent = "Auszahlung ist nur möglich, wenn das Turnier finished ist."; return; }

        if(!confirm("Wirklich alle offenen Netto-Beträge als Spieler-Einträge buchen?")) return;

        btnBookPayouts.disabled = true;

        try{
            const tName = tournamentCache?.name || `Turnier ${currentTid}`;
            const date = (tournamentCache?.date || new Date().toISOString().slice(0,10)); // falls du ein Turnier-Datum hast, nimm das

            // Wir buchen nur Spieler, die eine UID haben und noch nicht settled sind
            const toBook = (playersCache || []).filter(p => !!p?.uid && !p?.settledAt);

            let booked = 0;

            for(const p of toBook){
                const net = getPlayerNetEUR(p);

                await addTournamentEntryToUser({
                    userUid: p.uid,
                    dateISO: date,
                    amountEUR: net,
                    note: `Auszahlung: ${tName}`
                });

                await updateDoc(doc(db, "tournaments", currentTid, "players", p.id), {
                    settledAt: serverTimestamp()
                });


                booked++;
            }

            payoutMsg.textContent = booked
                ? `${booked} Spieler wurden gebucht.`
                : "Keine offenen Spieler zum Buchen gefunden.";

        }catch(err){
            payoutMsg.textContent = err?.message || "Buchen fehlgeschlagen.";
        }finally{
            btnBookPayouts.disabled = false;
        }
    });

    document.getElementById("btnAutoPlaces")
        .addEventListener("click", async () => {
            // Guard: nur wenn wirklich ALLE Spieler auf "out" sind
            const notOutCount = (playersCache || []).filter(p => (p?.status || "playing") !== "out").length;

            if(notOutCount > 0){
                alert("setzte zuerst alle spieler auf Out! WICHTIG nach reihenfolge wer rausgefallen ist!");
                return;
            }

            if(!confirm("Plätze automatisch anhand Ausscheiden setzen?")) return;


            btnBookPayouts.disabled = false;
            await autoAssignPlaces();
        });




</script>

<script>
    // Service Worker (optional)
    if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
            navigator.serviceWorker.register("./sw.js").catch(()=>{});
        });
    }
</script>

</body>
</html>

